%{
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <memory>
#include <boost/shared_ptr.hpp>
#include <vector>

#include "AST/Formula.h"
#include "AST/Regex.h"
#include "AST/TransitionSystem.h"
#include "Automata.h"
#include "CTL.h"
#include "Command.h"
#include "command/LoadFile.h"
#include "command/Null.h"
#include "command/Show.h"
#include "command/XShow.h"
#include "command/Quit.h"
#include "command/DeclareFormula.h"
#include "command/DeclareDFA.h"
#include "command/DeclareRegex.h"
#include "exception/ParseException.h"

using namespace std;
using namespace Command;

#include "Lex.h"
int yyparse(void);
int yywrap()
{
   return 1;
}

void yyerror(const char *error)
{
   throw ParseException(error);
}

// In which the result of the parse is stored
vector<Command::Command*> *commands_read = NULL;

std::vector<Command::Command*> CommandParser::ParseString(string input) {

   yy_scan_string( input.c_str() );
   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy();

   return *commands_read;
}

std::vector<Command::Command*> CommandParser::ParseFile(FILE *input) {

   YY_BUFFER_STATE buffer = yy_create_buffer ( input, YY_BUF_SIZE );
   yy_switch_to_buffer ( buffer );

   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy(); // TODO .. ??

   //yy_delete_buffer ( buffer );
   return *commands_read;
}

%}

%error-verbose

%union 
{
   char *string;
   AST::Formula::Formula* formula_ref;
   Command::Command* command_ref;
   AST::Regex::Regex* regex_ref;
   AST::Automaton* automaton_ref;
   vector<std::string> *string_list;
   vector<Command::Command*> *command_list;
}

// Declaration tokens
%token FORMULA_DECLARATION 
%token DFA_DECLARATION PDA_DECLARATION LTS_DECLARATION PDS_DECLARATION
%token REGEX_DECLARATION 

// Other command tokens
%token LOAD SHOW XSHOW QUIT
%token EMPTY LBRACE RBRACE LPAREN RPAREN

// General identifier
%token <string> IDENTIFIER 

// Formula tokens
%token FORMULA_FALSE FORMULA_TRUE
%token FORMULA_LPAREN FORMULA_RPAREN
%token FORMULA_LBRACKET FORMULA_RBRACKET
%token FORMULA_NOT FORMULA_AND FORMULA_OR FORMULA_IMPLICATION
%token FORMULA_A FORMULA_E FORMULA_U FORMULA_R FORMULA_G FORMULA_X 
%token <string> FORMULA_PVAR

// Regex tokens
%left  REGEX_OR
%left  REGEX_SEQ
%left  REGEX_KLEENE
%left  REGEX_ANY
%left  REGEX_ACTION
%left  REGEX_LPAREN 
%right REGEX_RPAREN 

%type <formula_ref> false true pvar not and or implication until release ax rule_formula
%type <string> formula_automaton_name

%type <command_ref> rule_command declare_formula declare_dfa declare_pda declare_lts declare_pds declare_regex
%type <string> formula_name automaton_name

%type <string> single_proposition action_name state_name
%type <string_list> proposition_list
%type <automaton_ref> rule_dfa rule_lts rule_pda rule_pds rule_automaton
%type <automaton_ref> automaton_component state kripke_state regular_action pushdown_action

%type <command_ref> null_command load_command quit_command show_command xshow_command
%token <string> QUOTED
%type <string> filename

%token <string> REGEX_ACTION
%type <regex_ref> rule_regex parenthesised_regex regex_kleene regex_seq regex_or regex_any regex_action

%token DFA_LPAREN DFA_RPAREN DFA_STATE DFA_COLON DFA_COMMA DFA_ACTION DFA_TRANSITION
%token <string> DFA_IDENTIFIER

%type <command_list> top rule_command_list unit_command_list cons_command_list

%%


top:
   rule_command_list
   {
      commands_read = $$;
   };

// COMMANDS

rule_command_list:
   unit_command_list | cons_command_list
   {
      $$ = $1;
   };

unit_command_list:
   rule_command
   {
      //CommandRef command($1);
      $$ = new vector<CommandRef>();
      $$->push_back($1);
   };

cons_command_list:
   rule_command_list rule_command
   {
      vector<Command::Command*> *xs = $1;
      Command::Command *x = $2;
      xs->push_back(x);
      $$ = xs;
   };

rule_command:
   declare_formula | declare_dfa | declare_pda | declare_lts | declare_pds | declare_regex | load_command | quit_command | show_command | xshow_command | null_command
   {
   };

null_command:
   EMPTY
   {
      $$ = new NullCommand();
   }

load_command:
   LOAD LPAREN filename RPAREN
   {
      $$ = new LoadFile($3);
   };

show_command:
   SHOW LPAREN IDENTIFIER RPAREN
   {
      $$ = new ShowCommand($3);
   }

xshow_command:
   XSHOW LPAREN IDENTIFIER RPAREN
   {
      $$ = new XShowCommand($3);
   }

quit_command:
   QUIT 
   {
      $$ = new QuitCommand();
   };

filename:
   QUOTED
   {
      $$ = $1;
   };

// DECLARATIONS

declare_formula:
   FORMULA_DECLARATION formula_name LBRACE rule_formula RBRACE
   {
      $$ = new DeclareFormulaCommand($2, *$4);
   };

declare_dfa:
   DFA_DECLARATION automaton_name LBRACE rule_dfa RBRACE
   {
      string name($2); free($2);
      $$ = new DeclareAutomatonCommand(name, $4);
   };

declare_pda:
   PDA_DECLARATION automaton_name LBRACE rule_pda RBRACE
   {
      string name($2); free($2);
      $$ = new DeclareAutomatonCommand(name, $4);
   };

declare_lts:
   LTS_DECLARATION automaton_name LBRACE rule_lts RBRACE
   {
      string name($2); free($2);
      $$ = new DeclareAutomatonCommand(name, $4);
   };

declare_pds:
   PDS_DECLARATION automaton_name LBRACE rule_pds RBRACE
   {
      string name($2); free($2);
      $$ = new DeclareAutomatonCommand(name, $4);
   };

declare_regex:
   REGEX_DECLARATION automaton_name LBRACE rule_regex RBRACE
   {
      //string name($2); free($2);
      $$ = new DeclareRegexCommand($2, $4);
      free($2)
   };

// REGULAR EXPRESSIONS

rule_regex:
   regex_seq | regex_or | regex_kleene | regex_action | regex_any | parenthesised_regex

parenthesised_regex:
   REGEX_LPAREN rule_regex REGEX_RPAREN %prec REGEX_LPAREN
   {
      $$ = $2;
   };

regex_seq:
   rule_regex rule_regex %prec REGEX_SEQ
   {
      $$ = new AST::Regex::Concat($1, $2);
   };

regex_or:
   rule_regex REGEX_OR rule_regex
   {
      $$ = new AST::Regex::Union($1, $3);
   };

regex_kleene:
   rule_regex REGEX_KLEENE %prec REGEX_KLEENE
   {
      $$ = new AST::Regex::Kleene($1);
   };

regex_action:
   REGEX_ACTION
   { 
      string action($1);
      $$ = new AST::Regex::Action(action);
      free($1);
   };

regex_any:
   REGEX_ANY 
   { 
      $$ = new AST::Regex::Any();
   };

// AUTOMATA

automaton_name:
   IDENTIFIER
   { $$ = $1; };

rule_dfa: rule_automaton
   { $$ = $1; $$->SetType(AST::Automaton::DFA); };

rule_lts: rule_automaton
   { $$ = $1; $$->SetType(AST::Automaton::LTS); };

rule_pda: rule_automaton
   { $$ = $1; $$->SetType(AST::Automaton::PDA); };

rule_pds: rule_automaton
   { $$ = $1; $$->SetType(AST::Automaton::PDS); };

rule_automaton: automaton_component
   { $$ = $1; };

rule_automaton: rule_automaton automaton_component
   {
      AST::Automaton *main_automaton = $1;
      AST::Automaton *to_add = $2;
      main_automaton->Assimilate(to_add);
      $$ = main_automaton;
   };

automaton_component:
   state | kripke_state | regular_action | pushdown_action
   { };

state:
   DFA_STATE DFA_LPAREN state_name DFA_RPAREN
   {
      string state_name($3);
      free($3);
      AST::State *state = new AST::State(state_name);
      $$ = new AST::Automaton(state);
   };

kripke_state:
   DFA_STATE DFA_LPAREN state_name DFA_COLON proposition_list DFA_RPAREN
   {
      string state_name($3);
      free($3);
      AST::KripkeState *state = new AST::KripkeState(state_name, *$5);
      delete $5;
      $$ = new AST::Automaton(state);
   };

proposition_list: single_proposition 
   {
      vector<string> *proposition_list = new vector<string>();
      proposition_list->push_back(string($1));
      free($1);
      $$ = proposition_list;
   };

proposition_list: proposition_list DFA_COMMA single_proposition
   {
      vector<string> *proposition_list = $1;
      proposition_list->push_back(string($3));
      free($3);
      $$ = proposition_list;
   };

single_proposition:
   DFA_IDENTIFIER
   {
      $$ = $1;
   };

regular_action:
   DFA_ACTION DFA_LPAREN action_name DFA_COLON state_name DFA_TRANSITION state_name DFA_RPAREN
   {
      string action_name($3);
      string state1_name($5);
      string state2_name($7);
      free($3);
      free($5);
      free($7);
      AST::State *state1 = new AST::State(state1_name);
      AST::State *state2 = new AST::State(state2_name);
      AST::RegularAction *action = new AST::RegularAction(action_name);
      $$ = new AST::Automaton(state1, action, state2);
   };

pushdown_action:
   DFA_ACTION DFA_LPAREN action_name DFA_COLON DFA_RPAREN
   {
      // TODO!!
   };

action_name:
   DFA_IDENTIFIER
   {
      $$ = $1;
   };

state_name:
   DFA_IDENTIFIER
   {
      $$ = $1;
   };

// PUSHDOWN SYSTEMS

rule_pda:
   {
   };

// ECTL FORMULA

formula_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_formula:
   not | and | or | implication | ax | until | release | false | true | pvar 
   {
   }
   ;

false:
   FORMULA_FALSE
   {
      $$ = new AST::Formula::False();
   }
   ;

true:
   FORMULA_TRUE 
   {
      $$ = new AST::Formula::True();
   }
   ;

pvar:
   FORMULA_PVAR
   {
      string name($1);
      $$ = new AST::Formula::PVar(name);
      free($1);
   }
   ;

not:
   FORMULA_NOT rule_formula
   {
     $$ = new AST::Formula::Negation($2);
   }
   ;

and:
   FORMULA_LPAREN rule_formula FORMULA_AND rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Conjunction($2, $4);
   }
   ;

or:
   FORMULA_LPAREN rule_formula FORMULA_OR rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Disjunction($2, $4);
   }
   ;

implication:
   FORMULA_LPAREN rule_formula FORMULA_IMPLICATION rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Implication($2, $4);
   }
   ;

ax:
   FORMULA_A FORMULA_X rule_formula
   {
     $$ = new AST::Formula::AX($3);
   }
   ;

formula_automaton_name:
   FORMULA_PVAR
   { // TODO ^ (change this?)
      //string name($1);
      $$ = $1;
      //free($1);
   }
   ;

until:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_U FORMULA_LBRACKET formula_automaton_name FORMULA_RBRACKET rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Until($3, $8, $6);
   };

release:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_R FORMULA_LBRACKET formula_automaton_name FORMULA_RBRACKET rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Release($3, $8, $6);
   };


