%{
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <memory>
#include <boost/shared_ptr.hpp>
#include <vector>

#include "AST/Formula.h"
#include "AST/Regex.h"
#include "CTL.h"
#include "Command.h"
#include "command/LoadFile.h"
#include "command/Null.h"
#include "command/Show.h"
#include "command/Quit.h"
#include "command/DeclareFormula.h"
#include "command/DeclareDFA.h"
#include "command/DeclareRegex.h"
#include "exception/ParseException.h"

using namespace std;
using namespace Command;

#include "Lex.h"
int yyparse(void);
int yywrap()
{
   return 1;
}

void yyerror(const char *error)
{
   throw ParseException(error);
}

// In which the result of the parse is stored
vector<Command::Command*> *commands_read = NULL;

std::vector<Command::Command*> CommandParser::ParseString(string input) {

   yy_scan_string( input.c_str() );
   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy();

   return *commands_read;
}

std::vector<Command::Command*> CommandParser::ParseFile(FILE *input) {

   YY_BUFFER_STATE buffer = yy_create_buffer ( input, YY_BUF_SIZE );
   yy_switch_to_buffer ( buffer );

   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy(); // TODO .. ??

   //yy_delete_buffer ( buffer );
   return *commands_read;
}

%}

%error-verbose

%union 
{
   char *string;
   AST::Formula::Formula* formula_ref;
   Command::Command* command_ref;
   AST::Regex::Regex* regex_ref;
   struct DFABasic* dfa_ref;
   vector<Command::Command*> *command_list;
}

%token FORMULA_DECLARATION DFA_DECLARATION PDA_DECLARATION REGEX_DECLARATION LOAD SHOW QUIT
%token EMPTY LBRACE RBRACE LPAREN RPAREN
%token <string> IDENTIFIER 

%token FORMULA_FALSE FORMULA_TRUE
%token FORMULA_LPAREN FORMULA_RPAREN
%token FORMULA_NOT FORMULA_AND FORMULA_OR FORMULA_IMPLICATION
%token FORMULA_A FORMULA_E FORMULA_U FORMULA_R FORMULA_G FORMULA_X 
%token <string> FORMULA_PVAR

%left REGEX_OR
%left REGEX_SEQ
%left REGEX_KLEENE
%left REGEX_ANY
%left REGEX_ACTION
%left REGEX_LPAREN 
%right REGEX_RPAREN 

%type <formula_ref> false true pvar not and or implication until release ax rule_formula

%type <command_ref> rule_command declare_formula declare_dfa declare_pda declare_regex
%type <string> formula_name dfa_name pda_name 
%type <dfa_ref> rule_dfa

%type <command_ref> null_command load_command quit_command show_command
%token <string> QUOTED
%type <string> filename

%token <string> REGEX_ACTION
%type <regex_ref> rule_regex parenthesised_regex regex_kleene regex_seq regex_or regex_any regex_action

%token DFA_LPAREN DFA_RPAREN DFA_STATE DFA_COLON DFA_COMMA DFA_ACTION DFA_TRANSITION
%token <string> DFA_IDENTIFIER

%type <command_list> top rule_command_list unit_command_list cons_command_list

%%


top:
   rule_command_list
   {
      commands_read = $$;
   };

// COMMANDS

rule_command_list:
   unit_command_list | cons_command_list
   {
      $$ = $1;
   };

unit_command_list:
   rule_command
   {
      //CommandRef command($1);
      $$ = new vector<CommandRef>();
      $$->push_back($1);
   };

cons_command_list:
   rule_command_list rule_command
   {
      vector<Command::Command*> *xs = $1;
      Command::Command *x = $2;
      xs->push_back(x);
      $$ = xs;
   };

rule_command:
   declare_formula | declare_dfa | declare_pda | declare_regex | load_command | quit_command | show_command | null_command
   {
   };

null_command:
   EMPTY
   {
      $$ = new NullCommand();
   }

load_command:
   LOAD LPAREN filename RPAREN
   {
      $$ = new LoadFile($3);
   };

show_command:
   SHOW LPAREN IDENTIFIER RPAREN
   {
      $$ = new ShowCommand($3);
   }

quit_command:
   QUIT 
   {
      $$ = new QuitCommand();
   };

filename:
   QUOTED
   {
      $$ = $1;
   };

// DECLARATIONS

declare_formula:
   FORMULA_DECLARATION formula_name LBRACE rule_formula RBRACE
   {
      $$ = new DeclareFormulaCommand($2, $4);
   };

declare_dfa:
   DFA_DECLARATION dfa_name LBRACE rule_dfa RBRACE
   {
      $$ = new DeclareDFACommand($2, $4);
   };

declare_regex:
   REGEX_DECLARATION dfa_name LBRACE rule_regex RBRACE
   {
      $$ = new DeclareRegexCommand($2, $4);
   };

declare_pda:
   PDA_DECLARATION pda_name LBRACE rule_pda RBRACE
   {
   };

// REGULAR EXPRESSIONS

rule_regex:
   regex_seq | regex_or | regex_kleene | regex_action | regex_any | parenthesised_regex
   {
   };


parenthesised_regex:
   REGEX_LPAREN rule_regex REGEX_RPAREN %prec REGEX_LPAREN
   {
      $$ = $2;
   };

regex_seq:
   rule_regex rule_regex %prec REGEX_SEQ
   {
      $$ = new AST::Regex::Concat($1, $2);
   };

regex_or:
   rule_regex REGEX_OR rule_regex
   {
      $$ = new AST::Regex::Union($1, $3);
   };

regex_kleene:
   rule_regex REGEX_KLEENE %prec REGEX_KLEENE
   {
      $$ = new AST::Regex::Kleene($1);
   };

regex_action:
   REGEX_ACTION
   { 
      string action($1);
      $$ = new AST::Regex::Action(action);
      free($1);
   };

regex_any:
   REGEX_ANY 
   { 
      $$ = new AST::Regex::Any();
   };

// DFA

dfa_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_dfa:
   rule_dfa dfa_component | dfa_component
   {
   };

dfa_component:
   dfa_state | dfa_action
   {
   };

dfa_state:
   DFA_STATE DFA_LPAREN dfa_state_name DFA_COLON dfa_proposition_list DFA_RPAREN
   {
   };

dfa_proposition_list:
   dfa_single_proposition | dfa_proposition_list DFA_COMMA dfa_single_proposition
   {
   };

dfa_single_proposition:
   DFA_IDENTIFIER
   {
      string name($1);
      free($1);
      // TODO $$ 
   };

dfa_action:
   DFA_ACTION DFA_LPAREN dfa_action_name DFA_COLON dfa_state_name DFA_TRANSITION dfa_state_name DFA_RPAREN
   {
   };

dfa_action_name:
   DFA_IDENTIFIER
   {
   };

dfa_state_name:
   DFA_IDENTIFIER
   {
   };

// PUSHDOWN SYSTEMS

pda_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_pda:
   {
   };

// ECTL FORMULA

formula_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_formula:
   not | and | or | implication | ax | until | release | false | true | pvar 
   {
   }
   ;

false:
   FORMULA_FALSE
   {
      $$ = new AST::Formula::False();
   }
   ;

true:
   FORMULA_TRUE 
   {
      $$ = new AST::Formula::True();
   }
   ;

pvar:
   FORMULA_PVAR
   {
      string name($1);
      $$ = new AST::Formula::PVar(name);
      free($1);
   }
   ;

not:
   FORMULA_NOT rule_formula
   {
     $$ = new AST::Formula::Negation($2);
   }
   ;

and:
   FORMULA_LPAREN rule_formula FORMULA_AND rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Conjunction($2, $4);
   }
   ;

or:
   FORMULA_LPAREN rule_formula FORMULA_OR rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Disjunction($2, $4);
   }
   ;

implication:
   FORMULA_LPAREN rule_formula FORMULA_IMPLICATION rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Implication($2, $4);
   }
   ;

ax:
   FORMULA_A FORMULA_X rule_formula
   {
     $$ = new AST::Formula::AX($3);
   }
   ;

until:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_U rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Until($3, $5);
   };

release:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_R rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Release($3, $5);
   };


