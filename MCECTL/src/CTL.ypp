%{
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <memory>
#include <boost/shared_ptr.hpp>

#include "AST/Formula.h"
#include "AST/Regex.h"
#include "CTL.h"
#include "Command.h"
#include "ParseException.h"

using namespace std;
using namespace AST::Regex;
using namespace AST::Formula;
using namespace Command;

extern "C"
{
   #include "Lex.h"
   int yyparse(void);
   int yywrap()
   {
      return 1;
   }
}

void yyerror(const char *error)
{
   throw ParseException(error);
}

// In which the result of the parse is stored
CommandRef temporary_command = NULL;

boost::shared_ptr<Command::Command> CommandParser::ParseString(string input) {

   yy_scan_string( input.c_str() );
   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy();

   return boost::shared_ptr<Command::Command>(temporary_command);
}


%}

%error-verbose

%union 
{
   char *string;
   struct Formula* formula_ref;
   struct Command* command_ref;
   struct Regex* regex_ref;
   struct DFABasic* dfa_ref;
}

%token FORMULA_DECLARATION DFA_DECLARATION PDA_DECLARATION REGEX_DECLARATION LOAD SHOW QUIT
%token EMPTY LBRACE RBRACE LPAREN RPAREN
%token <string> IDENTIFIER 

%token FORMULA_FALSE FORMULA_TRUE
%token FORMULA_LPAREN FORMULA_RPAREN
%token FORMULA_NOT FORMULA_AND FORMULA_OR FORMULA_IMPLICATION
%token FORMULA_A FORMULA_E FORMULA_U FORMULA_R FORMULA_G FORMULA_X 
%token <string> FORMULA_PVAR

%left REGEX_OR
%left REGEX_SEQ
%left REGEX_KLEENE
%left REGEX_ANY
%left REGEX_ACTION
%left REGEX_LPAREN 
%right REGEX_RPAREN 

%type <formula_ref> false true pvar not and or implication until release ax rule_formula

%type <command_ref> top rule_command declare_formula declare_dfa declare_pda declare_regex
%type <string> formula_name dfa_name pda_name 
%type <dfa_ref> rule_dfa

%type <command_ref> null_command load_command quit_command show_command
%token <string> QUOTED
%type <string> filename

%token <string> REGEX_ACTION
%type <regex_ref> rule_regex parenthesised_regex regex_kleene regex_seq regex_or regex_any regex_action

%token DFA_LPAREN DFA_RPAREN DFA_STATE DFA_COLON DFA_COMMA DFA_ACTION DFA_TRANSITION
%token <string> DFA_IDENTIFIER

%%


top:
   rule_command
   {
      temporary_command = $$;
   };

// COMMANDS

rule_command:
   declare_formula | declare_dfa | declare_pda | declare_regex | load_command | quit_command | show_command | null_command
   {
   };

null_command:
   EMPTY
   {
      $$ = new NullCommand();
   }

load_command:
   LOAD LPAREN filename RPAREN
   {
      $$ = new LoadFileCommand($3);
   };

show_command:
   SHOW LPAREN IDENTIFIER RPAREN
   {
      $$ = new ShowCommand($3);
   }

quit_command:
   QUIT 
   {
      $$ = new QuitCommand();
   };

filename:
   QUOTED
   {
      $$ = $1;
   };

// DECLARATIONS

declare_formula:
   FORMULA_DECLARATION formula_name LBRACE rule_formula RBRACE
   {
      $$ = new DeclareFormulaCommand($2, $4);
   };

declare_dfa:
   DFA_DECLARATION dfa_name LBRACE rule_dfa RBRACE
   {
      $$ = new DeclareDFACommand($2, $4);
   };

declare_regex:
   REGEX_DECLARATION dfa_name LBRACE rule_regex RBRACE
   {
      $$ = new DeclareRegexCommand($2, $4);
   };

declare_pda:
   PDA_DECLARATION pda_name LBRACE rule_pda RBRACE
   {
   };

// REGULAR EXPRESSIONS

rule_regex:
   regex_seq | regex_or | regex_kleene | regex_action | regex_any | parenthesised_regex
   {
   };


parenthesised_regex:
   REGEX_LPAREN rule_regex REGEX_RPAREN %prec REGEX_LPAREN
   {
      $$ = $2;
   };

regex_seq:
   rule_regex rule_regex %prec REGEX_SEQ
   {
      $$ = new AST::Regex::Concat($1, $2);
   };

regex_or:
   rule_regex REGEX_OR rule_regex
   {
      $$ = new AST::Regex::Union($1, $3);
   };

regex_kleene:
   rule_regex REGEX_KLEENE %prec REGEX_KLEENE
   {
      $$ = new AST::Regex::Kleene($1);
   };

regex_action:
   REGEX_ACTION
   { 
      string action($1);
      $$ = new AST::Regex::Action(action);
      free($1);
   };

regex_any:
   REGEX_ANY 
   { 
      $$ = new AST::Regex::Any();
   };

// DFA

dfa_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_dfa:
   rule_dfa dfa_component | dfa_component
   {
   };

dfa_component:
   dfa_state | dfa_action
   {
   };

dfa_state:
   DFA_STATE DFA_LPAREN dfa_state_name DFA_COLON dfa_proposition_list DFA_RPAREN
   {
   };

dfa_proposition_list:
   dfa_single_proposition | dfa_proposition_list DFA_COMMA dfa_single_proposition
   {
   };

dfa_single_proposition:
   DFA_IDENTIFIER
   {
      string name($1);
      free($1);
      // TODO $$ 
   };

dfa_action:
   DFA_ACTION DFA_LPAREN dfa_action_name DFA_COLON dfa_state_name DFA_TRANSITION dfa_state_name DFA_RPAREN
   {
   };

dfa_action_name:
   DFA_IDENTIFIER
   {
   };

dfa_state_name:
   DFA_IDENTIFIER
   {
   };

// PUSHDOWN SYSTEMS

pda_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_pda:
   {
   };

// ECTL FORMULA

formula_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_formula:
   not | and | or | implication | ax | until | release | false | true | pvar 
   {
   }
   ;

false:
   FORMULA_FALSE
   {
      $$ = new AST::Formula::False();
   }
   ;

true:
   FORMULA_TRUE 
   {
      $$ = new AST::Formula::True();
   }
   ;

pvar:
   FORMULA_PVAR
   {
      string name($1);
      $$ = new AST::Formula::PVar(name);
      free($1);
   }
   ;

not:
   FORMULA_NOT rule_formula
   {
     $$ = new AST::Formula::Negation($2);
   }
   ;

and:
   FORMULA_LPAREN rule_formula FORMULA_AND rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Conjunction($2, $4);
   }
   ;

or:
   FORMULA_LPAREN rule_formula FORMULA_OR rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Disjunction($2, $4);
   }
   ;

implication:
   FORMULA_LPAREN rule_formula FORMULA_IMPLICATION rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Implication($2, $4);
   }
   ;

ax:
   FORMULA_A FORMULA_X rule_formula
   {
     $$ = new AST::Formula::AX($3);
   }
   ;

until:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_U rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Until($3, $5);
   };

release:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_R rule_formula FORMULA_RPAREN
   {
     $$ = new AST::Formula::Release($3, $5);
   };


