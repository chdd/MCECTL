%{
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <memory>

#include "ctl_ast.h"
#include "CTL.h"
#include "Command.h"
#include <boost/shared_ptr.hpp>
#include "ParseException.h"

using namespace std;

extern "C"
{
#include "Lex.h"
   int yyparse(void);
   int yywrap()
   {
      return 1;
   }
}

void yyerror(const char *error)
{
   throw ParseException(error);
}

// In which the result of the parse is stored
command_ref temporary_command = NULL;

boost::shared_ptr<Command> CommandParser::ParseString(string input) {

   yy_scan_string( input.c_str() );
   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy();

   return boost::shared_ptr<Command>(temporary_command);
}


%}

%error-verbose

%token FALSE TRUE NOT AND OR LPAREN RPAREN A E U R G X FORMULA_DECLARATION DFA_DECLARATION PDA_DECLARATION REGEX_DECLARATION LOAD SHOW QUIT EMPTY ASSIGNMENT LBRACE RBRACE ASTERISK FULLSTOP

%union 
{
   char *string;
   struct formula* formula_ref;
   struct Command* command_ref;
   struct DFABasic* dfa_ref;
}

%token <string> IDENTIFIER 
%type <formula_ref> false;
%type <formula_ref> true;
%type <formula_ref> pvar;
%type <formula_ref> not;
%type <formula_ref> and;
%type <formula_ref> or;
%type <formula_ref> until;
%type <formula_ref> release;
%type <formula_ref> ax;
%type <formula_ref> rule_formula;

%type <command_ref> top;
%type <command_ref> rule_command;
%type <command_ref> declare_formula;
%type <command_ref> declare_dfa;
%type <command_ref> declare_pda;
%type <command_ref> declare_regex;
%type <string> formula_name;
%type <string> dfa_name;
%type <string> pda_name;

%type <dfa_ref> rule_dfa;

%type <command_ref> null_command;
%type <command_ref> load_command;
%type <command_ref> quit_command;
%type <command_ref> show_command;
%token <string> QUOTED;
%type <string> filename; 

%type <dfa_ref> rule_regex;
%type <dfa_ref> regex_kleene;
%type <dfa_ref> regex_seq;
%type <dfa_ref> regex_or;
%type <dfa_ref> regex_identifier;

%%


top:
   rule_command
   {
      temporary_command = $$;
   };

rule_command:
   declare_formula | declare_dfa | declare_pda | declare_regex | load_command | quit_command | show_command | null_command
   {
   };

null_command:
   EMPTY
   {
      $$ = new NullCommand();
   }

load_command:
   LOAD LPAREN filename RPAREN
   {
      $$ = new LoadFileCommand($3);
   };

show_command:
   SHOW LPAREN IDENTIFIER RPAREN
   {
      $$ = new ShowCommand($3);
   }

quit_command:
   QUIT 
   {
      $$ = new QuitCommand();
   };

filename:
   QUOTED
   {
      $$ = $1;
   };

declare_formula:
   FORMULA_DECLARATION formula_name LBRACE rule_formula RBRACE
   {
      $$ = new DeclareFormulaCommand($2, $4);
   };

formula_name:
   IDENTIFIER
   {
      $$ = $1;
   };

declare_dfa:
   DFA_DECLARATION dfa_name LBRACE rule_dfa RBRACE
   {
      $$ = new DeclareDFACommand($2, $4);
   };

declare_regex:
   REGEX_DECLARATION dfa_name LBRACE rule_regex RBRACE
   {
      $$ = new DeclareDFACommand($2, $4);
   };

rule_regex:
   regex_seq | regex_or | regex_kleene | regex_identifier
   {
   };

regex_seq:
   rule_regex rule_regex
   {
      dfa_ref dfa($1);
      dfa->Seq($2);
      $$ = dfa;
   };

regex_or:
   LPAREN rule_regex OR rule_regex RPAREN
   {
      dfa_ref dfa($2);
      dfa->Or($4);
      $$ = dfa;
   };

regex_kleene:
   rule_regex ASTERISK
   {
      dfa_ref dfa($1);
      dfa->Kleene();
      $$ = dfa;
   };

regex_identifier:
   IDENTIFIER 
   { 
      string action($1);
      $$ = new DFABasic(action);
   };

dfa_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_dfa:
// TODO
   {
   };
   

declare_pda:
   PDA_DECLARATION pda_name LPAREN rule_pda RPAREN
   {

   };

pda_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_pda:
   {
   };

rule_formula:
   not | and | or | ax | until | release | false | true | pvar 
   {
   }
   ;

false:
   FALSE
   {
      $$ = new formula_false();
   }
   ;

true:
   TRUE 
   {
      $$ = new formula_true();
   }
   ;

pvar:
   IDENTIFIER 
   {
      $$ = new formula_pvar($1);
   }
   ;

not:
   NOT rule_formula
   {
     $$ = new formula_not($2);
   }
   ;

and:
   LPAREN rule_formula AND rule_formula RPAREN
   {
     $$ = new formula_and($2, $4);
   }
   ;

or:
   LPAREN rule_formula OR rule_formula RPAREN
   {
     $$ = new formula_or($2, $4);
   }
   ;

ax:
   A X rule_formula
   {
     $$ = new formula_ax($3);
   }
   ;

until:
   E LPAREN rule_formula U rule_formula RPAREN
   {
     $$ = new formula_until($3, $5);
   };

release:
   E LPAREN rule_formula R rule_formula RPAREN
   {
     $$ = new formula_release($3, $5);
   };


