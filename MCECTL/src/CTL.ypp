%{
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <memory>

#include "ctl_ast.h"
#include "CTL.h"
#include "Command.h"
#include <boost/shared_ptr.hpp>
#include "ParseException.h"
#include "AST_Regex.h"

using namespace std;
using namespace AST::Regex;

typedef AST::Regex::Base *regex_reference;

extern "C"
{
   #include "Lex.h"
   int yyparse(void);
   int yywrap()
   {
      return 1;
   }
}

void yyerror(const char *error)
{
   throw ParseException(error);
}

// In which the result of the parse is stored
command_ref temporary_command = NULL;

boost::shared_ptr<Command> CommandParser::ParseString(string input) {

   yy_scan_string( input.c_str() );
   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy();

   return boost::shared_ptr<Command>(temporary_command);
}


%}

%error-verbose

%union 
{
   char *string;
   struct formula* formula_ref;
   struct Command* command_ref;
   struct Base* regex_ref;
   struct DFABasic* dfa_ref;
}

%token FORMULA_DECLARATION DFA_DECLARATION PDA_DECLARATION REGEX_DECLARATION LOAD SHOW QUIT
%token EMPTY LBRACE RBRACE LPAREN RPAREN
%token <string> IDENTIFIER 

%token FORMULA_FALSE FORMULA_TRUE
%token FORMULA_LPAREN FORMULA_RPAREN
%token FORMULA_NOT FORMULA_AND FORMULA_OR FORMULA_IMPLICATION
%token FORMULA_A FORMULA_E FORMULA_U FORMULA_R FORMULA_G FORMULA_X 
%token <string> FORMULA_PVAR

%left REGEX_OR
%left REGEX_SEQ
%left REGEX_KLEENE
%left REGEX_ANY
%left REGEX_ACTION
%left REGEX_LPAREN 
%right REGEX_RPAREN 

%type <formula_ref> false true pvar not and or until release ax rule_formula

%type <command_ref> top rule_command declare_formula declare_dfa declare_pda declare_regex
%type <string> formula_name dfa_name pda_name 
%type <dfa_ref> rule_dfa

%type <command_ref> null_command load_command quit_command show_command
%token <string> QUOTED
%type <string> filename

%token <string> REGEX_ACTION
%type <regex_ref> rule_regex  parenthesised_regex regex_kleene regex_seq regex_or regex_any regex_action

%%


top:
   rule_command
   {
      temporary_command = $$;
   };

// COMMANDS

rule_command:
   declare_formula | declare_dfa | declare_pda | declare_regex | load_command | quit_command | show_command | null_command
   {
   };

null_command:
   EMPTY
   {
      $$ = new NullCommand();
   }

load_command:
   LOAD LPAREN filename RPAREN
   {
      $$ = new LoadFileCommand($3);
   };

show_command:
   SHOW LPAREN IDENTIFIER RPAREN
   {
      $$ = new ShowCommand($3);
   }

quit_command:
   QUIT 
   {
      $$ = new QuitCommand();
   };

filename:
   QUOTED
   {
      $$ = $1;
   };

// DECLARATIONS

declare_formula:
   FORMULA_DECLARATION formula_name LBRACE rule_formula RBRACE
   {
      $$ = new DeclareFormulaCommand($2, $4);
   };

declare_dfa:
   DFA_DECLARATION dfa_name LBRACE rule_dfa RBRACE
   {
      $$ = new DeclareDFACommand($2, $4);
   };

declare_regex:
   REGEX_DECLARATION dfa_name LBRACE rule_regex RBRACE
   {
      $$ = new DeclareRegexCommand($2, $4);
   };

declare_pda:
   PDA_DECLARATION pda_name LBRACE rule_pda RBRACE
   {
   };

// REGULAR EXPRESSIONS

rule_regex:
   regex_seq | regex_or | regex_kleene | regex_action | regex_any | parenthesised_regex
   {
   };


parenthesised_regex:
   REGEX_LPAREN rule_regex REGEX_RPAREN %prec REGEX_LPAREN
   {
      cout << "Parenthesised" << endl;
      $$ = $2;
   };

regex_seq:
   rule_regex rule_regex %prec REGEX_SEQ
   {
      cout << "Seq" << endl;
      $$ = new AST::Regex::Concat($1, $2);
   };

regex_or:
   rule_regex REGEX_OR rule_regex
   {
      cout << "Or" << endl;
      $$ = new AST::Regex::Union($1, $3);
   };

regex_kleene:
   rule_regex REGEX_KLEENE %prec REGEX_KLEENE
   {
      cout << "Kleene" << endl;
      $$ = new AST::Regex::Kleene($1);
   };

regex_action:
   REGEX_ACTION
   { 
      cout << "Action " << $1 << endl;
      string action($1);
      $$ = new AST::Regex::Action(action);
   };

regex_any:
   REGEX_ANY 
   { 
      cout << "Any " << endl;
      $$ = new AST::Regex::Any();
   };

// DFA

dfa_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_dfa:
// TODO
   {
   };
   
// PUSHDOWN SYSTEMS

pda_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_pda:
   {
   };

// ECTL FORMULA

formula_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_formula:
   not | and | or | ax | until | release | false | true | pvar 
   {
   }
   ;

false:
   FORMULA_FALSE
   {
      $$ = new formula_false();
   }
   ;

true:
   FORMULA_TRUE 
   {
      $$ = new formula_true();
   }
   ;

pvar:
   FORMULA_PVAR
   {
      $$ = new formula_pvar($1);
   }
   ;

not:
   FORMULA_NOT rule_formula
   {
     $$ = new formula_not($2);
   }
   ;

and:
   FORMULA_LPAREN rule_formula FORMULA_AND rule_formula FORMULA_RPAREN
   {
     $$ = new formula_and($2, $4);
   }
   ;

or:
   FORMULA_LPAREN rule_formula FORMULA_OR rule_formula FORMULA_RPAREN
   {
     $$ = new formula_or($2, $4);
   }
   ;

ax:
   FORMULA_A FORMULA_X rule_formula
   {
     $$ = new formula_ax($3);
   }
   ;

until:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_U rule_formula FORMULA_RPAREN
   {
     $$ = new formula_until($3, $5);
   };

release:
   FORMULA_E FORMULA_LPAREN rule_formula FORMULA_R rule_formula FORMULA_RPAREN
   {
     $$ = new formula_release($3, $5);
   };


