%{
#include <cstdio>
#include <cstring>
#include <string>
#include <iostream>
#include <memory>

#include "ctl_ast.h"
#include "CTL.h"
#include "Command.h"
#include <boost/shared_ptr.hpp>
#include "ParseException.h"

using namespace std;

extern "C"
{
#include "Lex.h"
   int yyparse(void);
   int yywrap()
   {
      return 1;
   }
}
/*
   int yylex(void);  
   YY_BUFFER_STATE yy_scan_string ( const char *str );
}*/
void yyerror(const char *error)
{
   throw ParseException(error);
   //cerr << "Error: " << error << endl;
}

// In which the result of the parse is stored
command_ref temporary_command = NULL;

//formula_ref top_formula;

boost::shared_ptr<Command> CommandParser::ParseString(string input) {

   yy_scan_string( input.c_str() );
   try {
      yyparse();
   } catch (ParseException e) {
      yylex_destroy();
      throw;
   }
   yylex_destroy();

   return boost::shared_ptr<Command>(temporary_command);
}


%}

%error-verbose

%token FALSE TRUE NOT AND OR LPAREN RPAREN A E U R G X FORMULA_DECLARATION DFA_DECLARATION PDA_DECLARATION LOAD SHOW QUIT EMPTY ASSIGNMENT

%union 
{
   char *string;
   struct formula* formula_ref;
   struct Command* command_ref;
}

%token <string> IDENTIFIER 
%type <formula_ref> false;
%type <formula_ref> true;
%type <formula_ref> pvar;
%type <formula_ref> not;
%type <formula_ref> and;
%type <formula_ref> or;
%type <formula_ref> until;
%type <formula_ref> release;
%type <formula_ref> ax;
%type <formula_ref> rule_formula;

%type <command_ref> top;
%type <command_ref> rule_command;
%type <command_ref> declare_formula;
%type <command_ref> declare_dfa;
%type <command_ref> declare_pda;
%type <string> formula_name;
%type <string> dfa_name;
%type <string> pda_name;

%type <command_ref> load_command;
%type <command_ref> quit_command;
%token <string> QUOTED;
%type <string> filename; 

%%


top:
   rule_command
   {
      temporary_command = $$;
   };

rule_command:
   declare_formula | declare_dfa | declare_pda | load_command | quit_command | show_command
   {
   };

load_command:
   LOAD LPAREN filename RPAREN
   {
      $$ = new LoadFileCommand($3);
   };

show_command:
   SHOW LPAREN IDENTIFIER RPAREN
   {
      //. TODO
   }

quit_command:
   QUIT 
   {
      $$ = new QuitCommand();
   };

filename:
   QUOTED
   {
      $$ = $1;
   };

declare_formula:
   FORMULA_DECLARATION formula_name ASSIGNMENT rule_formula
   {
      $$ = new DeclareFormulaCommand($2, $4);
   };

formula_name:
   IDENTIFIER
   {
      $$ = $1;
   };

declare_dfa:
   DFA_DECLARATION dfa_name LPAREN rule_dfa RPAREN
   {
   };

dfa_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_dfa:
// TODO
   {
   };
   

declare_pda:
   PDA_DECLARATION pda_name LPAREN rule_pda RPAREN
   {

   };

pda_name:
   IDENTIFIER
   {
      $$ = $1;
   };

rule_pda:
   {
   };

rule_formula:
   not | and | or | ax | until | release | false | true | pvar 
   {
   }
   ;

false:
   FALSE
   {
      $$ = new formula_false();
   }
   ;

true:
   TRUE 
   {
      $$ = new formula_true();
   }
   ;

pvar:
   IDENTIFIER 
   {
      $$ = new formula_pvar($1);
   }
   ;

not:
   NOT rule_formula
   {
     $$ = new formula_not($2);
   }
   ;

and:
   LPAREN rule_formula AND rule_formula RPAREN
   {
     $$ = new formula_and($2, $4);
   }
   ;

or:
   LPAREN rule_formula OR rule_formula RPAREN
   {
     $$ = new formula_or($2, $4);
   }
   ;

ax:
   A X rule_formula
   {
     $$ = new formula_ax($3);
   }
   ;

until:
   E LPAREN rule_formula U rule_formula RPAREN
   {
     $$ = new formula_until($3, $5);
   };

release:
   E LPAREN rule_formula R rule_formula RPAREN
   {
     $$ = new formula_release($3, $5);
   };


