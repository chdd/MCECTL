\documentclass[11pt]{article}
\usepackage{cite}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsthm}
\newtheorem{mydef}{Definition}

\begin{document}

\title{Model Checking Extended Computation Tree Logic}
\author{Daniel Horgan}
\date{Today}
\maketitle

\begin{comment}
[scratch]
Blablabla said Nobody ~\cite{Nobody06}.
\end{comment}

\begin{abstract}

TODO abstract
Computation Tree Logic (CTL) is an effective way of modelling the behaviour of
simple systems over time, but there are properties which are beyond its power
to describe. More powerful logics such as CTL* (and ultimately the modal
mu-calculus) have the disadvantage that their model-checking problems are
intractable (EXPTIME as opposed to PTIME). A recent approach by Kreutzer et al
\cite{Kreutzer10} introduces the 'Extended CTL' family of logics, in which CTL
is parameterised by various classes of automata. This increases the expressive
power of the logic, whilst (in some cases) preserving the tractability of
model-checking. This project aims to implement a model checker for the PTIME
extensions of CTL described in \cite{Kreutzer10}.

\end{abstract}

\tableofcontents
\setcounter{tocdepth}{3}


\section{Introduction}


% move 1: background
%        - why is area important?
%        - background info
%        - previous research
% move 2: problem/need
% move 3: presenting project
%        - purposes,aims,objectives
%        - work carried out
%        - justification/importance
%        - outline of structure of report

\section{Background}

\subsection{Applications of Logic to Software Verification}

An important topic 
is software verification.
Model checking




In all of the following exposition, let $\textbf{Prop}$ be a countably infinite
set of proposition variables, let $\Sigma$ be a finite set of action names, and
let $\Gamma$ be a finite set of stack symbols.

\subsection{Computation-tree logic}

Standard CTL has become %TODO cite
one of the most widely-used logics for software verification, since it is both intuitive and computationally amenable.

with LTL

% define LTS
\begin{mydef}
A Labelled Transition System (LTS) is a triple $(\mathcal{S}, \rightarrow, l)$,
where $\mathcal{S}$ is a set of states, $\rightarrow \subseteq \Sigma \times
\Gamma \times \Sigma$ is the transition relation, and $l:\mathcal{S}
\rightarrow \mathcal{P}(A)$.
\end{mydef}

%define CTL
\begin{mydef}
A standard CTL formula is defined by
$\phi := q | \phi \vee \phi | \not \phi | E(\phi U \phi) | $%TODO
%semantics
A $\mathcal{T}, s \models \phi$ denotes that state $s \in \mathcal{T} = (\mathcal{S}, \rightarrow, l)$ satisfies the formula $\phi$, and is defined inductively over formulas as follows:

$\mathcal{T}, s \models q$ if $q \in l(s)$ \\
$\mathcal{T}, s \models \phi_1 \vee \phi_2$ if $\mathcal{T}, s \models \phi_1$ and $\mathcal{T}, s \models \phi_2$ \\
\end{mydef}

However, its expressive power is limited, and there are properties which we would like to be able to check that are beyond its power.
For example: 
% TODO example - buffer ?
To address this, more powerful logics have been proposed. CTL* % TODO CTL*
 PDL % TODO
and the modal mu-calculus
While these are all important and worthwhile tools, they suffer from two key problems: 
unintuitive
exponential-time model-checking


% Description of the formalism...
\subsection{Extended Computation-tree logic}

Note that in \cite{Kreutzer10}, the logic is defined for general classes of
automata. Here we are concerned only with the case of (non-deterministic)
pushdown automata, since this is the fragment for which we wish to implement
model-checking. In the terminology of \cite{Kreutzer10}, the logic defined
below is CTL[PDA,PDA].

% Define pushdown automata
\begin{mydef}
A pushdown automaton (PDA) $\mathcal{A}$ is a 5-tuple $(Q, \Sigma, \Gamma, \delta, q_0, F)$ where
$Q$ is a set of states, $\Sigma$ and $\Gamma$ are as established above,
$\delta$ is a set of pushdown transition rules, $q_0$ is the initial state, and
$F$ is the set of accepting states.
% TODO explain transition rules
\end{mydef}
% TODO semantics

% Define ectl
\begin{mydef}
The syntax for an Extended CTL formula is defined recursively as follows:
   $\phi := q | \phi \vee \phi | \not \phi | E(\phi U^\mathcal{A} \phi) | E(\phi
   R^\mathcal{A} \phi) $ 
where $q \in \textbf{Prop}$, and $\mathcal{A}$ is a PDA.
\end{mydef}

Formulas are evaluated with respect to the states of an LTS $\mathcal{T} = (\mathcal{S},
\rightarrow, l)$, according to the following semantics:
% TODO ectl semantics
$\mathcal{T}, s \models q$ iff $q \in l(s)$

%TODO define pushdown system
\begin{mydef} \end{mydef}

% define DFA?


\subsection{Model Checking}

Given a formula and a labelled transition system, the global model checking
problem consists of determining which states of the system satisfy the formula.


\subsection{Programs as Pushdown systems}

CTL extended by pushdown automata is an effective choice for verification of real programs

because the control flow of a recursive program can naturally be 
interpreted
as a pushdown system

\section{Requirements}

The aim of this project was to create a complete system for model-checking Extended CTL for the pushdown (i.e. context-free) case. 

input
output



\section{Design}

The core of the system is the MCECTL module; 

this accepts input in the form of commands in the MCECTL input language. 

Commands may update the internal state by defining new automata, systems and formulas.

They may produce output

% dot

Read-eval-print loop

% TODO bison/flex
% TODO repl; readline

The MCECTL input language is defined as follows.
Definitions are signalled by the keyword for the type of data being defined, in all caps (e.g. PDS) followed by the actual definition, in curly braces.
Commands in lower case and preceded by a colon 
for example, checking a formula against a system.

DFA
Declare a finite automaton explicitly

REGEX
Declare a finite automaton by providing a regular expression

PDA
Declare a pushdown automaton

LTS
Declare a labelled transition system

PDS
Declare a pushdown system 

FORMULA
Declare a formula

:load("input.ectl")
Load commands from the specified file.

:quit
End the session. (Also ctrl-D)

:check(formula, system)
Check which states of the system model the formula.

:show(formula)
:show(automaton)
:show(system)
Print a textual description of the named object.

:xshow(automaton)
:xshow(system)
Display a graphical representation of the named automaton or system.

% algorithm
\subsection{Model checking algorithm}

As with standard CTL, the global model-checking problem for CTL Extended with pushdown automaton admits a polynomial-time dynamic programming solution.

bottom-up
dynamic programming


Until

Release

\cite{EHRS00b}

\section{Testing}

\section{Conclusions}

I have implemented the first (to my knowledge) system for automated solution of
the global model checking problem for CTL extended by pushdown automata.

\section{Acknowledgements}

I am very grateful to Stephan Kreutzer for acting as my supervisor for this project, in which capacity he ... TODO

%TODO

\section{References}
\bibliography{references}{}
\bibliographystyle{plain}



\end{document}
