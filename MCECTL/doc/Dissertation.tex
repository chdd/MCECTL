\documentclass[11pt]{article}
\pdfpagewidth 210mm
\pdfpageheight 297mm
\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.0in}
\setlength\textwidth{6.0in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}

\usepackage{cite}
\usepackage{verbatim}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{lscape}
\usepackage{multicol}

\newtheorem{mydef}{Definition}

\begin{document}

\title{Model Checking Extended Computation Tree Logic}
\author{Daniel Horgan}
\date{Today}
\maketitle

\begin{comment}
[scratch]
Blablabla said Nobody ~\cite{Nobody06}.
\end{comment}

\begin{abstract}

TODO abstract
Computation Tree Logic (CTL) is an effective way of modelling the behaviour of
simple systems over time, but there are properties which are beyond its power
to describe. More powerful logics such as CTL* (and ultimately the modal
mu-calculus) have the disadvantage that their model-checking problems are
intractable (EXPTIME as opposed to PTIME). A recent approach by Kreutzer et al
\cite{Kreutzer10} introduces the 'Extended CTL' family of logics, in which CTL
is parameterised by various classes of automata. This increases the expressive
power of the logic, whilst (in some cases) preserving the tractability of
model-checking. This project aims to implement a model checker for the PTIME
extensions of CTL described in \cite{Kreutzer10}.

\end{abstract}

\newpage

\tableofcontents
\setcounter{tocdepth}{3}

\newpage


\section{Introduction}


% move 1: background
%        - why is area important?
%        - background info
%        - previous research
% move 2: problem/need
% move 3: presenting project
%        - purposes,aims,objectives
%        - work carried out
%        - justification/importance
%        - outline of structure of report

\section{Background}

\subsection{Applications of Logic to Software Verification}

An important topic 
is software verification.
Model checking




In all of the following exposition, let $\textbf{Prop}$ be a countably infinite
set of proposition variables, let $\Sigma$ be a finite set of action names, and
let $\Gamma$ be a finite set of stack symbols.

\subsection{Computation-tree logic}

Standard CTL has become %TODO cite
one of the most widely-used logics for software verification, since it is both intuitive and computationally amenable.

with LTL

% define LTS
\begin{mydef}
A Labelled Transition System (LTS) is a triple $(\mathcal{S}, \rightarrow, l)$,
where $\mathcal{S}$ is a set of states, $\rightarrow \subseteq \Sigma \times
\Gamma \times \Sigma$ is the transition relation, and $l:\mathcal{S}
\rightarrow \mathcal{P}(A)$.
\end{mydef}

%define CTL
\begin{mydef}
A standard CTL formula is defined by
$\phi := q | \phi \vee \phi | \not \phi | E(\phi U \phi) | $%TODO
%semantics
A $\mathcal{T}, s \models \phi$ denotes that state $s \in \mathcal{T} = (\mathcal{S}, \rightarrow, l)$ satisfies the formula $\phi$, and is defined inductively over formulas as follows:

$\mathcal{T}, s \models q$ if $q \in l(s)$ \\
$\mathcal{T}, s \models \phi_1 \vee \phi_2$ if $\mathcal{T}, s \models \phi_1$ and $\mathcal{T}, s \models \phi_2$ \\
\end{mydef}

However, its expressive power is limited, and there are properties which we would like to be able to check that are beyond its power.
For example: 
% TODO example - buffer ?
To address this, more powerful logics have been proposed. CTL* % TODO CTL*
 PDL % TODO
and the modal mu-calculus
While these are all important and worthwhile tools, they suffer from two key problems: 
unintuitive
exponential-time model-checking


% Description of the formalism...
\subsection{Extended Computation-tree logic}

Note that in \cite{Kreutzer10}, the logic is defined for general classes of
automata. Here we are concerned only with the case of (non-deterministic)
pushdown automata, since this is the fragment for which we wish to implement
model-checking. In the terminology of \cite{Kreutzer10}, the logic defined
below is CTL[PDA,PDA].

% Define pushdown automata
\begin{mydef}
A pushdown automaton (PDA) $\mathcal{A}$ is a 5-tuple $(Q, \Sigma, \Gamma, \delta, q_0, F)$ where
$Q$ is a set of states, $\Sigma$ and $\Gamma$ are as established above,
$\delta$ is a set of pushdown transition rules, $q_0$ is the initial state, and
$F$ is the set of accepting states.
% TODO explain transition rules
\end{mydef}
% TODO semantics

% Define ectl
\begin{mydef}
The syntax for an Extended CTL formula is defined recursively as follows:
   $\phi := q | \phi \vee \phi | \not \phi | E(\phi U^\mathcal{A} \phi) | E(\phi
   R^\mathcal{A} \phi) $ 
where $q \in \textbf{Prop}$, and $\mathcal{A}$ is a PDA.
\end{mydef}

Formulas are evaluated with respect to the states of an LTS $\mathcal{T} = (\mathcal{S},
\rightarrow, l)$, according to the following semantics:
% TODO ectl semantics
$\mathcal{T}, s \models q$ iff $q \in l(s)$

%TODO define pushdown system
\begin{mydef} \end{mydef}

% define DFA?


\subsection{Model Checking}

Given a formula and a labelled transition system, the global model checking
problem consists of determining which states of the system satisfy the formula.


\subsection{Programs as Pushdown systems}

CTL extended by pushdown automata is an effective choice for verification of real programs

because the control flow of a recursive program can naturally be 
interpreted
as a pushdown system

\section{Requirements}

The aim of this project was to create a complete system for model-checking
Extended CTL for the pushdown (i.e. context-free) case. 

A number of key requirements were identified, and these goals helped to direct
the design process. 


\subsection{Correctness}
The first priority for the system was -- perhaps obviously -- that of
correctness. Since one of the primary applications of model-checking in general
is the analysis and verification of other programs, it is vital that
an implementation produce accurate results. Mainstream adoption of formal
verification methods has been slow,\cite{mitra2008strategies} and if these
techniques are ever to be more widely used, they must in the first place be
reliable.

% use algorithms that are proven correct, where possible
% testing

\subsection{Usability}

Using the system should be simple and practical.

The system must accept problem specifications in a clear format, 
and produce results in an intelligible manner.

\subsection{Efficiency}

Less important than accuracy, but nevertheless desirable is that the system
should be computationally efficient. 

Naturally, the size of the models which can be checked will be limited by the
amount of memory available. Since real-world applications of the system will
involve models generated from analysis of potentially large pieces of software,
we may desire to check very large systems. Therefore, the algorithms used
should be space-efficient, and the implementation should not be wasteful.

Time-efficiency is of equal importance: since the key advantage of formal
verification is that it saves time by finding problems which would otherwise
only be caught by extensive testing, a tool's usefulness can easily be
undermined if it takes a long time to produce results.

\subsection{Extensibility}

A minor consideration 

\subsection{Integration}
 %jimple
A secondary goal is to provide some means of applying the model-checker to pushdown systems modelling the control flow of real programs. Most software is complex enough that manually creating such systems would be neither practical nor reliable. Hence there is a need for a way of producing the appropriate pushdown system automatically from program source code.

A similar project which performs this task is Matthew Hague's \textbf{PDSolver}.
The 
% cite
% PDSolver

\section{Design}


% class breakdown, diagrams ?

% algorithms, data structures

% user interface


% regex

The core of the system is the MCECTL module; 

this accepts input in the form of commands in the MCECTL input language. 

Commands may update the internal state by defining new automata, systems and formulas.
stored internally

They may produce output

Read-eval-print loop
% TODO repl; GNU readline

% dot

\subsection{Input}
input language is tokenised and parsed using \textbf{flex} and \textbf{Bison} respectively. 
% TODO bison/flex

An Abstract Syntax Tree is constructed recursively 




% algorithm
\subsection{Model checking algorithm}

As with standard CTL, the global model-checking problem for CTL Extended with
pushdown automaton admits a polynomial-time dynamic programming solution.

Specifically, the problem of checking a formula can be divided into the
sub-problems of checking the sub-formulas. %TODO rewrite

bottom-up
% visitor pattern

\subsection{Until}

\subsection{Release}
% section from kreutzer paper
To check the LTL formula, we use a method based on the one described in \cite{EHRS00b} %TODO check right cite

But since we only need to be able to check the specific type of LTL formula
that occurs here, it is possible to make some simplifications.

\section{Testing}

% examples ?


% strategy for testing
% results ?


\section{Application to Checking Java Programs}

%PDsolver and jimple

\section{Conclusions}

% summary
I have implemented the first (to my knowledge) system for automated solution of
the global model checking problem for CTL extended by pushdown automata.
% achievements

%critical appraisal

% lessons learnt

%further work


\section{Acknowledgements}

I am very grateful to Stephan Kreutzer for acting as my supervisor for this project, in which capacity he ... TODO

%TODO Matthew Hague

\bibliography{references}{}
\bibliographystyle{plain}

\appendix
\section{User Manual}

The MCECTL input language is defined as follows.
Definitions are signalled by the keyword for the type of data being defined, in all caps (e.g. PDS) followed by the actual definition, in curly braces.
Commands in lower case and preceded by a colon 
for example, checking a formula against a system.

DFA
Declare a finite automaton explicitly

REGEX
Declare a finite automaton by providing a regular expression

PDA
Declare a pushdown automaton

LTS
Declare a labelled transition system

PDS
Declare a pushdown system 

FORMULA
Declare a formula

:load("input.ectl")
Load commands from the specified file.

:quit
End the session. (Also ctrl-D)

:check(formula, system)
Check which states of the system model the formula.

:show(formula)
:show(automaton)
:show(system)
Print a textual description of the named object.

:xshow(automaton)
:xshow(system)
Display a graphical representation of the named automaton or system.
This requires that graphviz is installed, and that the `dot' tool is present in
the system PATH.

%TODO convert.pl


\section{Code Listings}

\lstset{ %
language=C++,                % the language of the code
basicstyle=\footnotesize\ttfamily,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                % will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,                   % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                % also try caption instead of title
}

\setlength\topmargin{0in}
\setlength\leftmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.0in}
\setlength\textwidth{7.0in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\begin{landscape}
%\begin{multicols}{2}{
\lstinputlisting[language=C++]{src/MCECTL.cpp}
%}
%\end{multicols}
\end{landscape}
\end{document}
