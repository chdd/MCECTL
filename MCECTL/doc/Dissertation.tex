\documentclass[11pt]{article}
\pdfpagewidth 210mm
\pdfpageheight 297mm
\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.0in}
\setlength\textwidth{6.0in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}

\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{lscape}
\usepackage{multicol}
\usepackage{verbatim}

% figures with borders
\usepackage{float}
\floatstyle{boxed} 
\restylefloat{figure}

% no indents
\usepackage{parskip}

\usepackage[pdftex]{graphicx}
\usepackage{graphviz}

\usepackage{alltt}

\theoremstyle{definition}
\newtheorem{mydef}{Definition}

% TODOs general:
% MCECTL name


\begin{document}

\title{Model Checking Extended Computation Tree Logic}
\author{Daniel Horgan}
% don't put candidate no.
\maketitle

\begin{abstract}

%TODO abstract
%Move 1:  Background to the project
Computation Tree Logic is widely used for modelling the behaviour of simple
systems over time, but its expressive power is limited.  More powerful logics
such as CTL* and the modal mu-calculus have the disadvantage that their
model-checking problems are comparatively intractable, and they can be
unintuitive.  A recent contribution by Axelsson et al. introduces the `Extended
CTL' family of logics, in which the Until and Release operators of CTL are
parameterised by various classes of automaton. This has the advantage of
increasing the expressive power of the logic, whilst (in the case of pushdown
automata) preserving the tractability of model checking. 
%Move 2: Purpose of the project
%Move 3: Problem tackled
Using algorithms based on those described in the paper, this project implements
(to the best of my knowledge) the first concrete system for model checking
CTL[PDA, DPDA], the logic in which both operators are refined by pushdown
automata, which are deterministic in the case of Release. 
%Move 4: Work carried out
%Move 5: Results 
%Move 6: Conclusions or implications
%Move 7: Achievements of the project
As well as a robust and tested core checking procedure, we provide a set of
commands for loading and displaying automata, systems and formulas. It is
possible to check both regular and pushdown systems, and checking a fixed
formula is possible in time polynomial in the size of the system and the
automata used.


\end{abstract}

\newpage

\tableofcontents
\setcounter{tocdepth}{3}

\newpage

\section{Introduction}

% move 1: background
%        - why is area important?
Automatic formal verification of programs is an important topic in computer
science, because it is difficult to evaluate correctness properties of complex
programs manually. One of the main approaches is based on \textit{model
checking}: relevant aspects of the behaviour of a program are represented as an
abstract logical model, and the program specification is formulated as a set of
formulas of a corresponding logic. By checking whether the model satisfies the
formulas, we can discover whether the program meets the specification they
embody.

%        - background info
Many different logics have been developed and used in this way; amongst the
most popular have been the temporal logics CTL and LTL. Their formulas are
evaluated over \textit{labelled transition systems}: such systems consist of a
finite set of states at which various propositions may hold, together with
rules specifying the possible movements between them. % TODO rewrite

%        - previous research
% move 2: problem/need
While both of these logics are useful and well-studied, they are unable to
express many of the more complicated properties that we may wish to check.
Moreover, labelled transition systems cannot directly be used to represent
programs with infinitely many states. Since we wish to permit software with
unbounded recursion, this is a severe limitation. For example, consider the
case of a shared resource whose lifetime is controlled by reference-counting.
We wish to check that the count is decremented exactly the same number of times
as it is incremented, and that the count does not reach zero before it is safe
for the resource to be released. Since the count may legitimately become
arbitrarily large, a finite state system cannot be used to track this property.

% efficient, but not powerful: 
% can't do buffer specification; non-regular
% can't do infinite states; mostly used for hardware

More powerful logics have their own problems\footnote{A detailed justification
for Extended CTL is given by Axelsson et al. (2010), upon which this summary is
based.}. The model checking problem for CTL* is
PSPACE-complete\cite{Kreutzer10}\cite{sistla1985complexity}

The modal mu-calculus   %TODO

%CTL*, mu-calculus
% others?

To address these issues, Axelsson et al. have developed a group of new logics 
in which CTL is extended by classes of automata (or, equivalently, of formal languages)

% TODO
it was shown, in particular, that CTL[PDA, DPDA] was in P


As well as being computationally efficient, this technique is relatively
intuitive. Many programmers have a good understanding of regular expressions
and context-free grammars, but the fixed-point operators which lend the modal
mu-calculus its power are likely to be unfamiliar.

% move 3: presenting project
%        - purposes,aims,objectives

At least in theory, then, CTL[PDA, DPDA] has good potential as a practical
logic for software verification. For this reason, and to determine to what
extent this is borne out in practice, the primary aim of this project was to
create a concrete, working implementation of the model checking algorithms
described in Axelsson et al.

%        - work carried out

% TODO ?
To this end, an input language was defined for specifying pushdown and
non-pushdown automata and systems, as well as extended CTL formulas.  A set of
commands is provided for interacting with these objects, and in particular for
checking formulas against systems.  This is possible both when the pushdown
component is in the automaton and when it is in the transition system.

%        - justification/importance

%        - outline of structure of report

The report is structured as follows. We formally define the syntax and
semantics of CTL[PDA,DPDA], based on the description in the paper. We also
recall the algorithms for model checking the Until and Release clauses set out
therein, and elaborate on them with some thought to implementation.

\section{Background}

In all of the exposition that follows, let $\textbf{Prop}$ be a countably
infinite set of proposition variables, let $\Sigma$ be a finite set of action
names, and let $\Gamma$ be a finite set of stack symbols.

\subsection{Computation-tree logic}

Standard CTL has become %TODO cite
one of the most widely-used logics for software verification, since it is both
intuitive and computationally amenable.

with LTL

To better understand the nature of extended CTL, we now briefly recall the
usual definitions of syntax and semantics for ordinary CTL.

% define LTS
\begin{mydef}
A Labelled Transition System (LTS) is a triple $\mathcal{T} = (\mathcal{S}, \rightarrow, l)$,
where $\mathcal{S}$ is a set of states, $\rightarrow \subseteq \Sigma \times
\Gamma \times \Sigma$ is the transition relation, and $l:\mathcal{S}
\rightarrow \mathcal{P}(\textbf{Prop})$ is a labelling function.
\end{mydef}

%define CTL
\begin{mydef}
The syntax of a standard CTL formula is defined recursively by

\[ \phi := q | \phi \vee \phi | \neg \phi | \texttt{E}(\phi_1 \texttt{U} \phi_2) | \texttt{E}(\phi_1 \texttt{R} \phi_2) \]

$\mathcal{T}, s \models \phi$ denotes that state $s \in \mathcal{S}$ satisfies
the formula $\phi$, which 
inductively over formulas as follows:

$\mathcal{T}, s \models q$ if $q \in l(s)$ \\
$\mathcal{T}, s \models \phi_1 \vee \phi_2$ if $\mathcal{T}, s \models \phi_1$
or $\mathcal{T}, s \models \phi_2$ \\
$\mathcal{T}, s \models \neg \phi $ if $\mathcal{T}, s \not\models \phi$ \\
$\mathcal{T}, s \models \texttt{E}(\phi_1 \texttt{U} \phi_2) $ if there exists
a path $\pi = s_0,a_1,s_1,\dots$ with $s_0 = s$ and $\exists n \in dom(\pi)$ s.t. $s_n \models \psi$ and $\forall i < n : \mathcal{T}, s_i \models \phi$ \\
%TODO \\
$\mathcal{T}, s \models \texttt{E}(\phi_1 \texttt{R} \phi_2) $ if %TODO \\

\end{mydef}
%However, its expressive power is limited, and there are properties which we
%would like to be able to check that are beyond its power.
%For example: 
% TODO example - buffer ?
%To address this, more powerful logics have been proposed. CTL* % TODO CTL*
% PDL % TODO
%and the modal mu-calculus
%While these are all important and worthwhile tools, they suffer from two key problems: 
%unintuitive
%exponential-time model-checking


% Description of the formalism...
\subsection{Extended Computation-tree logic}

Note that in \cite{Kreutzer10}, the logic is defined for general classes of
automata. Here we are concerned only with the case of (non-deterministic) %TODO
pushdown automata, since this is the fragment for which we wish to implement
model-checking. In the terminology of \cite{Kreutzer10}, the logic defined
below is CTL[PDA,DPDA].

% Define pushdown automata
\begin{mydef}
A pushdown automaton (PDA) $\mathcal{A}$ is a 5-tuple $(Q, \Sigma, \Gamma, \Delta, q_0, F)$ where
$Q$ is a set of states, $\Sigma$ and $\Gamma$ are as established above,
$\Delta$ is a set of pushdown transition rules, $q_0$ is the initial state, and
$F$ is the set of accepting states.
% TODO explain transition rules
\end{mydef}
% TODO semantics

% Define ectl
\begin{mydef}
The syntax for an Extended CTL formula is defined recursively as follows:
   \[ \phi := q | \phi \vee \phi | \neg \phi | \texttt{E}(\phi \texttt{U}^\mathcal{A} \phi) | \texttt{E}(\phi
   \texttt{R}^\mathcal{B} \phi) \]
where $q \in \textbf{Prop}$, $\mathcal{A}$ is a PDA, and $\mathcal{B}$ is a DPDA.

Formulas are evaluated with respect to states of an LTS $\mathcal{T} = (\mathcal{S},
\rightarrow, l)$, according to the following semantics:

%\begin{center}
% TODO ectl semantics
$\mathcal{T}, s \models q$ iff $q \in l(s)$
$\mathcal{T}, s \models q$ iff $q \in l(s)$ \\
$\mathcal{T}, s \models \phi_1 \vee \phi_2$ iff $\mathcal{T}, s \models \phi_1$
or $\mathcal{T}, s \models \phi_2$ \\
$\mathcal{T}, s \models \neg \phi $ iff $\mathcal{T}, s \not\models \phi$ \\
$\mathcal{T}, s \models \texttt{E}(\phi_1 \texttt{U}^\mathcal{A} \phi_2) $ iff 
$\exists$ a path $\pi = s_0, a_1, s_1, \dots$ with $s_0 = s$ and $\exists n \in dom(\pi)$ s.t. $a_1 \dots a_n \in L(\mathcal{A}$ and $\mathcal{T}, s_n \models \psi$ and $\forall i < n : \mathcal{T}, s_i \models \phi$
\\ %TODO 
$\mathcal{T}, s \models \texttt{E}(\phi_1 \texttt{R}^\mathcal{A} \phi_2) $ iff 
$\exists$ a path $\pi = s_0, a_1, s_1, \dots$ with $s_0 = s$ and $\forall n \in dom(\pi): a_1 \dots a_n \not\in L(\mathcal{A}$ or $\mathcal{T}, s_n \models \psi$ or $\exists i < n$ s.t. $\mathcal{T}, s_i \models \phi$\\ %TODO
%\end{center}
\end{mydef}

%TODO define pushdown system
\begin{mydef} A pushdown system is \end{mydef}

% define DFA?


\subsection{Model Checking}

Given a formula and a labelled transition system, the global model checking
problem consists of determining which states of the system satisfy the formula.
The %TODO

\subsection{Applications of Logic to Software Verification}

An important topic 
is software verification.
Model checking


% ...

\subsection{Programs as Pushdown systems}

CTL extended by pushdown automata is an effective choice for verification of
real programs because the control flow of a recursive program can naturally be
modelled by a pushdown system. In this case, the stack of the pushdown system
corresponds directly to the call stack of the program.



\section{Requirements}

The aim of this project was to create a complete system for model-checking
Extended CTL for the pushdown (i.e. context-free) case. 

A number of key requirements were identified, and these goals helped to direct
the design process. 

\subsection{Correctness}

The first priority for the system was -- perhaps obviously -- that of
correctness. Since one of the primary applications of model-checking in general
is the analysis and verification of other programs, it is vital that an
implementation produce accurate results. Mainstream adoption of formal
verification methods has been slow\cite{mitra2008strategies}, and if these
techniques are ever to be more widely used, they must in the first place be
reliable.

The key algorithms used should therefore be proven correct, and care must be
taken to ensure that the implementation reflects the abstract version.
Ultimately though, establishing confidence in the checking procedures will
require extensive testing.

\subsection{Usability}

Using the system should be simple and practical.  The system must accept
problem specifications in a clear format, and produce results in an
intelligible manner.  If a state is found to satisfy an existence formula, a
trace should be provided as evidence.  This is important for the software
verification use case, since the knowledge that a program does not meet a
specification is not very useful without some indication as to why this is.

\subsection{Efficiency}

Less important than accuracy, but nevertheless desirable is that the system
should be computationally efficient. 

Naturally, the size of the models which can be checked will be limited by the
amount of memory available. Since real-world applications of the system will
involve models generated from analysis of potentially large pieces of software,
we may desire to check very large systems. Therefore, the algorithms used
should be space-efficient, and the implementation should not be wasteful.

Time-efficiency is of equal importance: since the key advantage of formal
verification is that it saves time by finding problems which would otherwise
only be caught by extensive testing, a tool's usefulness can easily be
undermined if it takes a long time to produce results.

\subsection{Extensibility}

The system should be extensible

\subsection{Integration}
 %jimple
A secondary goal is to provide some means of applying the model-checker to
pushdown systems modelling the control flow of real programs. Most software is
complex enough that manually creating such systems would be neither practical
nor reliable. Hence there is a need for a way of producing the appropriate
pushdown system automatically from program source code.

%TODO ??

\section{Design}

The design process essentially followed a top-down model. It was clear that
certain specific sub-systems would be required:
\begin{itemize}
\item{\textbf{Input}: some way of reading model checking problems into the system}
\item{\textbf{Core}:  the actual model checking algorithms}
\item{\textbf{Output}: printing results and traces obtained from checks}
\end{itemize}

Central to all of these systems would be the data structures used in the
checking process.  

Since the model checking algorithms are highly
automata-theoretic, it was clear that an important component of the system
would need to be a set of automata classes with support for certain necessary
operations. In particular, two of the most significant features required were
the ability to construct a minimised DFA from a regular expression, and to
compute the predecessor configurations of a set in a pushdown system. %TODO
rewrite

Unfortunately, investigation found no single pre-existing library of automata
classes which would support all of these. For this reason, it was necessary to
develop new classes for the various types of automata and systems, and use the
various libraries by converting between the different representations as
necessary.  This was perhaps less elegant than an entirely self-contained
solution, but was a pragmatic approach -- since the focus of the project was
the new model checking algorithm, it made sense to use robust and well-tested
external code where possible, rather than re-implement these algorithms from
scratch.

% why C++ ? -libraries

C++ was chosen for this project because it allows for linkage with the wpds
library (which is written in C) whilst permitting an object-oriented approach.

\subsection{Overview}

The user interacts with the system via a command line. A typical session
involves loading system and formula definitions from a file, followed by
specifying checks to run against these objects. It is also possible to display
the automata and systems that have been loaded.

The interpretation of the command text, whether input directly or loaded from a file, is handled by 
%TODO



\subsection{Systems and Automata}

By using C++ templates, it was possible to create the four necessary
automaton\footnote{For brevity, the term `automata' is taken here also to
include transition systems} types (DFA, PDA, LTS, PDS) as a single class (with
two template parameters).  The class is parameterised by \textit{state type}
and \textit{action type}.  Using the plain \texttt{State} class results in
automata; using \texttt{KripkeState} produces systems, with labelled states.
Similarly, \texttt{RegularAction} and \texttt{PushDownAction} provide the
different types of transition rule used.

This approach reduced code duplication and increased flexibility; for example,
to create the product system used for the Until checking, it was sufficient to
change the state type to a new \texttt{ProductState} class, acting as a pair
\texttt{(State, KripkeState)} drawn from the Cartesian product.

\subsection{Configuration Space}

%configuration space

While the control states of the automata are stored explicitly, the actual
configurations are not\footnote{Here `configuration' refers to a combination of
a control state and a top stack symbol.}; instead, an automaton has an
associated `configuration space', which is used whenever it is necessary to
directly make reference to configurations. The configuration space stores the
names of control states and of stack symbols, and associates each pair thereof
with a unique integer. This ID number is used to refer to states and
configurations in the transition rules and elsewhere, so that potentially long
name strings do not need to be copied unnecessarily. It also simplifies the
construction of product systems.

% class breakdown, diagrams ?

% algorithms, data structures

% user interface

%SHOWABLE

\subsection{Regular Expressions}
% regex, libfa
Since it can be tedious to define automata manually, it is also possible to
specify a DFA using a regular expression. The regex is parsed into its own AST
-- as with the other structures -- but when interpreted, libfa is used to
construct a DFA with the name given. The decision to use libfa was taken
because to reimplement the necessary minimisation algorithms would have been
time-consuming and potentially less robust. However, libfa naturally uses its
own representation for automata and regular expressions, so we need to convert
between them to retrieve the results. This is done by the
\texttt{DeclareRegexCommand} class.

% environment
\subsection{Environment}

The environment is used to store all of the automata, systems, and formulas
that have been loaded at any given point in the program. It also stores the
results of model-checks, so that it is only necessary to check a formula once
-- to recall the results again, they are simply looked up in the environment.
This has the potential to save computation time if the user wishes to check
several similar formulas against a system. It also allows the user a greater
degree of interactivity; it's possible to define and check a new formula during
a session, without needing to reload the transition system.

\subsection{Read-eval-print loop}

Given the usability requirements, a traditional read-eval-print loop was an
obvious choice as a front-end to the system.  The REPL makes use of the
\textbf{GNU readline} library, so that standard keyboard shortcuts can be used
for such operations as retrieving previously entered commands from the history,
and auto-completing filenames. 

A full graphical user interface would have provided an even greater degree of
usability, but was judged to be beyond the scope of this project. However,
since the main core of the model checker is built as a separate (static)
library, it would be easy to extend the system with an alternative front-end.

% dot


\subsection{Input}
The input language is tokenised and parsed using \textbf{flex} and
\textbf{Bison} respectively. See the Appendix for a detailed explanation of the
input language.
% TODO bison/flex

An Abstract Syntax Tree is constructed recursively during the parse; ultimately
the input text is transformed into a series of Command objects. This helps to
modularise functionality, and means that the actual execution of the commands
can be delayed. As well as generally adding flexibility, this decision means
that it is possible to ensure definitions are well-formed before they are
undertaken.

In the case of formulas, the intermediate representation as an AST has another
advantage: it affords an opportunity to rewrite clauses into another form.
This allows us to provide model checking procedures for only a minimal portion
of the logic; other types of formula are converted to this according to the
usual equivalences.

In particular, checking procedures are implemented for the base cases true and
false, propositional variables, negation, conjunction,
$\texttt{E}(\phi\texttt{U}\psi)$ and $\texttt{E}(\phi\texttt{R}\psi)$.

Disjunction and implication are handled by transforming the AST as follows:
\[ \phi \vee \psi \equiv \neg ( \neg \phi \wedge \neg \psi ) \]
\[ \phi \rightarrow \psi \equiv \neg ( \phi \wedge \neg \psi ) \]

By a similar duality, we can define the universal path quantifiers:\cite{Kreutzer10}
\[ \texttt{A}(\phi\texttt{U}\psi) \equiv \neg\texttt{E}(\neg\phi\texttt{R}\neg\psi) \]
\[ \texttt{A}(\phi\texttt{R}\psi) \equiv \neg\texttt{E}(\neg\phi\texttt{U}\neg\psi) \]

%TODO EX AX

% algorithm
\subsection{Model checking algorithm}

As with standard CTL, the global model-checking problem for CTL Extended with
pushdown automaton admits a polynomial-time dynamic programming solution.

Specifically, the problem of checking a formula has sub-problems of checking
each of the sub-formulas. In the %TODO

In dynamic programming, one achieves an efficient solution by solving the
sub-problems in topological order; in our case this simply means checking the
sub-formulas in a `bottom up' manner. 


% visitor pattern
We use the Visitor pattern to recurse over the structure of the formula being
checked. This allows us to break up the code with a separate method for
checking each type of clause, and the check action is dispatched according to
the class of the formula.
% dynamic dispatch



\subsection{Basic clauses}

\subsection{Until}

\begin{figure}[h!] %TODO
\caption{\textbf{Until} checking algorithm}
\begin{enumerate}
\item{Check subformulas}

\item{Construct product system}

\item{Construct an automaton recognising the configurations which are accepting and also satisfy the second subformula.}

\item{Compute their predecessor configurations.}

\item{For each state of the system:
   check whether the state's `bottom configuration' is a predecessor.}
   \end{enumerate}
\end{figure}

\subsection{Release}

% section from kreutzer paper

In Axelsson et al. (2010) the problem of checking
$\texttt{E}(x\texttt{R}^\mathcal{A}y)$ is reduced to evaluating the LTL formula
\texttt{F}$p_b$ on a constructed pushdown system $\mathcal{A}_\mathcal{T} = (Q
\times \mathcal{S} \cup \{g, b\}, \Gamma, \Delta, l')$, where 

\begin{displaymath}
   l'(s) =  \left\{
     \begin{array}{lr}
       \{p_b\} & \text{if} \hspace{2mm} s = b\\
       \{\} & \text{if}  \hspace{2mm} s = g \\
       l(s) & \text{otherwise}
     \end{array}
   \right.
\end{displaymath}
   
and 

\begin{displaymath}
   ((p,s),\gamma) \rightarrow \left\{
     \begin{array}{ll}
       (g, \epsilon) & \text{if } s \in l'(x) \text{ and} \\
                     & (p \in F \text{ implies } s \in l'(y)) \\
       & \\
       (b, \epsilon) & \text{if}  \hspace{2mm} p \in F \text{ and } s \not \in l'(y) \\
       & \\
       ((q,t),w)     & \text{if neither of the above match} \\
                     & \text{and there exists } a \in \Sigma \text{ s.t. } \\
                     & s \xrightarrow{a} t \text{ and } (p, a, \gamma) \rightarrow (q, w) \\
                     & \text{ for some } \gamma \in \Gamma, w \in \Gamma^*
     \end{array}
   \right.
\end{displaymath}

% LTL checking
To check the LTL formula, we use a method based on the one described in Esparza et al. (2000)\cite{EHRS00b}.

\begin{figure}[h!]
\caption{Checking an LTL formula against a pushdown system: method from Esparza et al. (2000)\cite{EHRS00b} }
\begin{enumerate}
\item{Construct a B\"{u}chi automaton $\mathcal{B}$ with initial state $q_0$ corresponding to the negation of the formula}
\item{Compute the B\"{u}chi pushdown system $\mathcal{BP}$ as the product of $\mathcal{B}$ and the pushdown system}
\item{Compute the set of repeating heads $R$ of $\mathcal{BP}$}
\item{Construct an automaton $\mathcal{A}$ accepting $R\Gamma^*$.}
\item{Compute $pre^*(R\Gamma^*)$}
\end{enumerate}
A configuration $\langle p, w \rangle$ violates the formula iff $\mathcal{A}_{pre^*}$ accepts $\langle (p, q_0 ), w\rangle$.

\end{figure}

But since we only need to be able to check the specific type of LTL formula
that occurs here, it is possible to make some simplifications.

The first step in checking \texttt{F}$p_b$ is to construct a B\"{u}chi
automaton corresponding to the negation of the formula. This will have one
state, which is accepting, and has a self-loop for every valuation except those
in which $p_b$ is true. 

\[ 
\mathcal{B} := (\Sigma_\mathcal{B}, Q_\mathcal{B}, \delta_\mathcal{B}, q_{0_\mathcal{B}}, F_\mathcal{B})
\]
where
\begin{displaymath}
     \begin{array}{cc}
     \Sigma_\mathcal{B} := 2^{\textbf{Prop}}                        
     & Q_\mathcal{B} := \{ * \} \\
     \delta_\mathcal{B} := \{ * \xrightarrow{v} * : v \in 2^{\textbf{Prop}\backslash\{p_b\}}  \}
     & q_{0_\mathcal{B}} := * \\
        & F_\mathcal{B} := \{*\}
   \end{array}
\end{displaymath}
(`*' is used as the name of the single state, since this is arbitrary)


Following the standard definition\cite{EHRS00b}, the product of this B\"{u}chi automaton with our pushdown system, then, is a B\"{u}chi pushdown system given by:

\[ 
\mathcal{BA_T} = ( (Q \times \mathcal{S} \cup \{g, b\}) \times Q_\mathcal{B}, \Gamma, \Delta', G) 
\]
where
%TODO
\[ G = \{ (p, *) : p \in Q \times \mathcal{S} \cup \{g, b\} \} \]
and 
\[ \langle (p, *), \gamma \rangle \hookrightarrow \langle (p', *), w\rangle \in \Delta' 
\text{ iff } \langle p, \gamma \rangle \hookrightarrow \langle p', w \rangle, *
\xrightarrow{\sigma} *\text{ and }\sigma \subseteq l'(\langle p, \gamma
\rangle) \]
Noting that $* \xrightarrow{\sigma} *$ iff $\sigma \subseteq \textbf{Prop}\backslash\{p_b\}$ we obtain 
\[ \langle (p, *), \gamma \rangle \hookrightarrow \langle (p', *), w\rangle \in \Delta' 
\text{ iff } \langle p, \gamma \rangle \hookrightarrow \langle p', w \rangle,\text{ and } \textbf{Prop}\backslash\{p_b\} \cap l'(\langle p, \gamma
\rangle) \neq \emptyset\]

or equivalently

\[ \langle (p, *), \gamma \rangle \hookrightarrow \langle (p', *), w\rangle \in \Delta' 
\text{ iff } \langle p, \gamma \rangle \hookrightarrow \langle p', w \rangle,\text{ and } \{ p_b \} \neq l'(\langle p, \gamma \rangle) \]

But note further that $ \{ p_b \} \neq l'(\langle p, \gamma \rangle) $ iff $ p
\neq b $ by construction of the pushdown system. In fact, we see that there are no rules with $b$ as a head state -- so finally we simply have:

\[ \langle (p, *), \gamma \rangle \hookrightarrow \langle (p', *), w\rangle \in \Delta' 
\text{ iff } \langle p, \gamma \rangle \hookrightarrow \langle p', w \rangle \]

and clearly in fact $\mathcal{BA_T} \cong \mathcal{A_T}$ via $(p, *) \mapsto p$.

% Compute repeating heads
The next step is to compute the repeating heads of $\mathcal{BA_T}$.

% Compute pre*(R\Gamma^*)




\begin{figure}[h!] %TODO
\caption{\textbf{Release} checking algorithm}
Hence our final algorithm is (in pseudo-code):
\begin{enumerate}
\item{Check the sub-formulas}
\item{Construct the Release pushdown system, as above}
\item{Construct an automaton recognising the `stack bottom' configurations}
\item{Compute their predecessor configurations}
\item{Create a reachability graph}
\item{Find its strongly connected components}
\item{A vertex is a repeating head if it is in a component with an edge, or it has no successors.}
\item{Construct an automaton recognising the repeating heads}
\item{Compute their predecessor configurations}
\item{For each state, check whether its `stack bottom' configuration is a predecessor}
\end{enumerate}
\end{figure}

\subsection{WPDS Wrapper}

Since libwpds is written in C and so has a non-object oriented interface, a
wrapper class was used to simplify the code and prevent unnecessary access to
the internal data structures. The library must also be initialised and
de-initialised before and after use; using a wrapper means this can be
performed conveniently via the constructor/destructor methods. In the case of
release checking, it is necessary to compute two sets of predecessor
configurations, so two instances of the wrapper class are used simultaneously
-- for this reason, a count of the active instances of libwpds is kept, so that
initialisation and de-initialisation need only be performed once.

\section{Examples}

% TODO

\section{Testing}

Since correctness of the checking procedure is of great importance, a
systematic test strategy was developed. This included unit testing of some
subsystems, as well as extensive black-box testing of the whole system.

For the unit tests, the \textbf{Boost Unit Test Framework} was used, since this
granted a direct interface to the classes being tested. The black-box tests, in
contrast, concerned only the input and ultimate output. For this reason, a
separate script was written in Perl, which sends problems to the model checker
via standard input, and then verifies that the received output matches the
expected output. This script uses the standard Perl \textbf{Test::More} test
harness.

\subsection{Unit tests}

Unit tests were used primarily for the part of the system which dealt with
parsing. The tests each checked that the AST resulting from parsing some string
matched the expected one (or failed to parse, if the string was invalid). These
tests were helpful during development for preventing regressions as new
features were added.

%TODO
Example:
\begin{alltt}
test_case_t("FORMULA foo { E(hungry U[dfa] eat) }",
            "FORMULA foo { [[PVAR hungry] UNTIL {AUTOMATA dfa} [PVAR eat]] }"),
\end{alltt}
checks that an \textbf{Until} formula parses.

Example:
\begin{alltt}
test_case_t("REGULAR foo { (toast|coffee)* }",
            "REGULAR foo { [KLEENE [[ACTION toast] UNION [ACTION coffee]]] }"),
\end{alltt}
checks a regular expression's AST.

See the appendix for a full list.

\subsection{Black Box tests}
% examples ?

The black-box tests are specified in self-contained Perl hash objects, and are
all evaluated independently, using different sessions of MCECTL. The results
for each state are extracted using a regular expression, and compared with
those expected.

Example:
\begin{alltt}
\{
   name     => "2. LTS, five states, pushdown with one symbol",
   formula  => \{ name => "phi8", formula => "E( 1 U[a8] p )" \},
   system   => \{
      type => "LTS", 
      name => "t13", 
      states => ['t0 : ' ,'t1 : ' ,'t2 : ' ,'t3 : ' ,'t4 : ' ,'t5 : p'],
      rules => [ 'a:t0->t1' ,'b:t1->t2' ,'a:t2->t3' ,'b:t3->t4' ,'c:t4->t5']
   \},
   automata => [
      \{
         type => "PDA",
         name => "a8",
         states => [ 's1', '*s2' ],
         rules => [
            'a: s1[_] -> s1[PUSH s]',
            'b: s1[s] -> s1[POP]',
            'c: s1[_] -> s2[REWRITE _]'
         ]
      \}
   ],
   expected => \{ t0 => 1, t1 => 0, t2 => 1, t3 => 0, t4 => 1, t5 => 0\}
\}
\end{alltt}

This is one of the cases for testing \textbf{Until} checking.

The transition system:

\digraph[scale=0.9]{BlackBoxExampleLTS1}{
   rankdir=LR; 
   margin=0;
   fixedsize=true;
	node [shape = circle,  width=0.3] t0 t1 t2 t3 t4 t5;
	t0 -> t1 [ label = "a" ];
	t1 -> t2 [ label = "b" ];
	t2 -> t3 [ label = "a" ];
	t3 -> t4 [ label = "b" ];
	t4 -> t5 [ label = "c" ];
}

where $p$ holds at \texttt{t5} only.

The pushdown automaton:

\digraph[scale=0.9]{BlackBoxExamplePDA1}{
   rankdir=LR; 
   margin=0;
	node [shape = circle,  width=0.3] s1;
	node [shape = doublecircle,  width=0.3] s2;
	node [shape = plaintext, label=""] INIT;
	INIT -> s1 [ label = "" ];
	s1 -> s1 [ label = "a: _/s" ];
	s1 -> s1 [ label = "b: s/_" ];
	s1 -> s2 [ label = "c: _/_" ];
}

The formula: $\phi = $ \texttt{E}( true $\texttt{R}^{\mathcal{A}}$ $p$ ), where
$\mathcal{A}$ is the above automaton.

It is clear that the automaton accepts the language \{ (ab)*c \}. States t1, t3
and t5 have no initial $a$-transition, so there can be no accepting path to a
$p$-state from these. States t0, t2 and t4 do have such paths though, as
$(\text{t0}, \text{s1}) \xrightarrow{a} (\text{t1}, \text{s1}) \xrightarrow{b}
(\text{t2}, \text{s1}) \xrightarrow{a} (\text{t3}, \text{s1}) \xrightarrow{b}
(\text{t4}, \text{s1}) \xrightarrow{c} (\text{t5}, \text{s2})$ in the product
system.

Hence t0, s2, s4 are expected to be satisfying, whereas the other states are
not. This is specified in the test case.

The results returned by the model checker are:
\footnotesize
\begin{alltt}
Results: {
   t0: T     [ <> s(s1,t0) --a--> <_> s(s1,t1) --b--> <> s(s1,t2) --a--> 
               <_> s(s1,t3) --b--> <> s(s1,t4) --c--> <> s(s2,t5)__ ]
   t1: F
   t2: T     [ <> s(s1,t2) --a--> <_> s(s1,t3) --b--> <> s(s1,t4) --c--> <> s(s2,t5)__ ]
   t3: F
   t4: T     [ <> s(s1,t4) --c--> <> s(s2,t5)__ ]
   t5: F
}
\end{alltt}
\normalsize
so the test passes.

%TODO
% strategy for testing
% results ?


\section{Application to Checking Java Programs}

%PDsolver and jimple
% TODO
A similar project which performs this task is Matthew Hague's
\textbf{PDSolver}\cite{hague2010analysing}.  The focus of PDSolver is checking
modal mu-calculus properties; however, it includes a \textbf{JimpleToPDSolver}
tool for extracting pushdown control-flow graphs from Java programs. This tool
produces output in the format used by PDSolver; by combining it with a script
for converting PDSolver problems to MCECTL ones, we can obtain a convenient way
of applying the model checker to real programs.

\section{Conclusions}

% summary
I have implemented the first (to my knowledge) system for automated solution of
the global model checking problem for CTL[PDA,DPDA].
% regular expressions, jimple
% testing
%TODO

% achievements

%critical appraisal

% lessons learnt

%further work

\subsection{Further work}

While the system works well and demonstrates the potential usefulness of
Extended CTL as a logic for program verification, there is much scope to
improve upon this initial implementation. 

% BNF context-free
There are a number of features which could improve the usability of the system
considerably, if added.

Perhaps most obviously, it would be convenient to allow the non-regular portion
of a formula or model to be described by a context-free grammar in the input.
Currently it is necessary to explicitly enter states and rules for a pushdown
automaton, which can be unintuitive. 

% determinise NPDAs
Similarly, since the algorithm for checking Release formulas only works with
DPDAs, it would be helpful for the system to automatically determinise PDAs
when necessary.

% optimisation


Work by Lal and Reps\cite{lal2006improving} offers an alternative algorithm for
reachability analysis of pushdown systems; it may be worth investigating
whether their tool is able to improve upon the performance of the wpds library
in practice.
% BDDs
For systems with very large numbers of variables, it would be sensible to use
Binary Decision Diagrams to represent valuations symbolically. 
This approach has been undertaken successfully by such projects as
Bebop\cite{ball2000bebop} and NuSMV\cite{cimatti2002nusmv}; indeed it has been
applied to the checking of pushdown systems at least in the case of
LTL\cite{esparza2001bdd}.

% integration

Finally, there is much scope for better integration with other systems, to
better allow verification of real programs. It would be possible, for example,
to create an Eclipse plug-in for automatically building a pushdown control flow
graph from a source file, and perhaps checking a set of standard formulas
against it.

Similarly, it is possible to use GCC to create control flow graphs of C++ code;
tools for checking these conveniently could be very useful.

\section{Acknowledgements}

I am very grateful to Stephan Kreutzer for acting as my supervisor for this
project, in which capacity he was most helpful.

I would also like to thank Matthew Hague for his help with searching for
automata libraries and general advice concerning PDSolver.

\bibliography{references}{}
\bibliographystyle{plain}
%\bibliographystyle{apalike}

\appendix
\section{User Manual}

\subsection{Compilation}

If you wish to build MCECTL yourself, you will require the following:
\begin{alltt}
CMake >= 2.8.2
Boost >= 1.43.0
GNU Bison >= 2.4.3
flex >= 2.5.35
GNU Readline >= 6.1.002
\end{alltt}

Earlier versions may work, but this has not been tested.

All other libraries used are provided with the source distribution. These include:
\begin{alltt}
libfa >= 0.7.4 (part of the Augeas project)
wpds >= 16/05/2006 (available from the Institute of Formal Methods 
in Computer Science, University of Stuttgart)
\end{alltt}

From the main directory, the following commands will build the system:
\begin{alltt}
$ cmake .
$ make
\end{alltt}

This produces two executables: \textbf{MCECTL-REPL}, for using the system
interactively, and \textbf{Test}, which runs the Boost unit tests. 

\subsection{MCECTL-REPL}

MCECTL-REPL takes two command line options.
\begin{alltt}
--verbose         If this flag is present, produce more detailed output
--file filename   Load and execute commands from a file
\end{alltt}

\subsection{Input Language}

The MCECTL input language is defined as follows.
Definitions are signalled by the keyword for the type of data being defined, in
all caps (e.g. PDS) followed by the actual definition, in curly braces.

Commands in lower case and preceded by a colon 
for example, checking a formula against a system.

\begin{alltt}
DFA
Declare a finite automaton explicitly

REGEX
Declare a finite automaton by providing a regular expression

PDA
Declare a pushdown automaton

LTS
Declare a labelled transition system

PDS
Declare a pushdown system 

FORMULA
Declare a formula

:load("input.ectl")
Load commands from the specified file.

:quit
End the session. (Also ctrl-D)

:check(formula, system)
Check which states of the system model the formula.
If the system is an LTS, any formula automata should be PDAs.
If the system is a PDS, the formula automata should be DFAs.

:show(formula)
:show(automaton)
:show(system)
Print a textual description of the named object.

:xshow(automaton)
:xshow(system)
Display a graphical representation of the named automaton or system.
This requires that GraphViz is installed, and that the `dot'
tool is present in the system PATH.
\end{alltt}

\subsection{Conversion from JimpleToPDSolver output}



%TODO convert.pl


\section{Code Listings}

%% NOT USED ? %%

\begin{comment}
\lstset{ %
language=C++,                % the language of the code
basicstyle=\footnotesize\ttfamily,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                % will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=single,                   % adds a frame around the code
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                % also try caption instead of title
}

\setlength\topmargin{0in}
\setlength\leftmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.0in}
\setlength\textwidth{7.0in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\begin{landscape}
%\begin{multicols}{2}{
\lstinputlisting[language=C++]{src/MCECTL.cpp}
%}
%\end{multicols}
\end{landscape}
\end{comment}
\end{document}
