\documentclass[a4paper,11pt,titlepage,english]{article}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO List
%%
%% - Make sure that the two forms of specifications of array index ranges
%% can be mixed in declarations of two-dimensional arrays. (Passed to Remy.)
%%
%% - Make sure that 'undef' works properly with arrays, structures and
%% enums. (Passed to Remy.)
%%
%% - This document talks about LTL model checking even if it is not
%% implemented yet. The implementation should comply with this
%% documentation then. :)
%% 
%% Search "TODO" throughout the document for more TODOs.
%% 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% What This Document Does Not Cover - possible TODOs
%%
%% - Primed variables. This document does not mention them at all. Perhaps
%% they are beyond the scope of any version of this document.
%%
%% - Pushdown system rules are not covered yet. They should not be used in
%% Remopla code anyway and the explanation is not required unless the
%% semantics is explained via symbolic PDAs.
%% 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Document policy
%%
%% Try to keep the LaTeX source clean and try to avoid any extra formatting
%% commands in the text. You should do well with the commands described
%% here.
%%

% BNF Grammar of Remopla
% ----------------------
% 
% This section takes advantage of the 'bnfgrammar' environment defined in
% the file 'remopla.sty'. The environment allows a BNF grammar of the
% Remopla language to be typeset easily. The grammar may be split into
% several environments. The synopsis of a single environment is as follows.
%
% \begin{bnfgrammar}
% [non terminal] \is clause 1 \or clause 2 \or ...\\
% ...
% [non terminal] \is clause 1 \or clause 2 \or ...\\
% \end{bnfgrammar}
%
% The environment cannot be used in an argument of a LaTeX command. The
% content of the environment is processed in a special way:
% - spaces are processed as in a regular paragraph (multiple spaces count
%   as a single space, they cannot be used for formatting)
% - lines matter; end of line in the source produces line break in the
%   output
% - '<' character has a special meaning - it starts a non-terminal - and
%   cannot be used elsewhere; use \lt instead
% - characters '{', '}', '&', '^' and '_' can be used as in verbatim
%   environment; you can use \obr, \cbr, \amp, \car and \usc,
%   respectively, if you need the original meaning
%
% Any string delimited with '<' and '>' characters is considered
% a non-terminal. Terminals are written directly.
%
% Each rule starts with a non-terminal followed by the \is command. Then
% comes the right-hand side of the rule. Several rules for a single
% non-terminal can be put together by delimiting the respective right-hand
% sides by \or command. A rule is terminated by the \\ command.
%
% A rule can occupy several lines. The lines in the source code and in the
% output must be in one-to-one correspondence. The output will not be
% formatted properly otherwise. The indentation in the source code does not
% matter.
%
% Non-terminals are typeset as hypertext links. A non-terminal on
% a right-hand side of a rule is link to the definition of that
% non-terminal. Because of this, all rules for a given non-terminal must
% form a single rule in the BNF. The link destination would not be defined
% correctly otherwise.
%
% The hypertext structure provides another advantage as a side effect. The
% pdfTeX checks that all non-terminals in the right-hand sides are defined
% and that no non-terminal is defined at two distinct places. 
%
% The following warning message of pdfTeX means the 'constant' nonterminal
% is defined at two distinct places.
%   ! pdfTeX warning (ext4): destination with the same identifier (name{constant})
%   has been already used, duplicate ignored
%
%   ! pdfTeX warning (dest): name{quantification} has been referenced but does not
%   exist, replaced by a fixed one
%   


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Creating Output
%%
%% This LaTeX document uses pdfTeX functionality. Use
%%      pdflatex introduction.tex
%% to generate camera-ready output. Any standard TeX distribution should be
%% enough for this document, e.g. TeXLive2003.
%%
%% There is a Makefile, too. Just type 'make'.
%% 

%% Run-time check that gives a more comprehensive error message instead of
%% nothing-telling 'Undefined command sequence.' that would be produced
%% otherwise.
\ifx\pdfoutput\undefined
    \ClassError{introduction}
        {You must use pdfTeX ('pdflatex') to process this document.}
        {You must use pdfTeX ('pdflatex') to process this document.}
\else
    \ifnum\pdfoutput=0
        \ClassWarning{introduction}
            {pdfTeX has been switched to produce PDF output.} 
            {pdfTeX has been switched to produce PDF output.} 
        \pdfoutput=1
    \fi
\fi


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Document Preamble
%% 
%% Here is how we achieve the behaviour described above.
%%

%% The document language is English.
%% The encoding of the file is ISO-8859-1.
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}

%% Load Remopla specific settings and environments.
\usepackage{remopla}

%% Hyphenation Exceptions
\hyphenation{Re-mop-la}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Document Body
%%
\begin{document}



%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
%% TODO: adjust title page (references to funding projects etc)
\title{\Huge\bfseries Introduction to Remopla}
\author{
    Jan Hole\v{c}ek\\
    Dejvuth Suwimonteerabuth\\
    Stefan Schwoon\\
    Javier Esparza}
\date{August 2006}
{\let\large=\Large
\maketitle
}

\tableofcontents
\clearpage

%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Model Checking Models in Remopla\label{s:modelchecking}}

% Todo: This part should be restructured as follows:
%	Give an example of a Remopla program and how to use
%	it with Moped (command line etc).
%	Shift the part about finite and infinite runs into
%	a section of its own.

The Remopla language, an input language of the Moped model
checker~\cite{Schwoon02}, is aimed at modeling behaviours of finite-domain
programs with (possibly) unbounded recursive procedure calls. The model
checker implements reachability analysis and general LTL model checking
over models in Remopla.

This document gives an informal semantics of Remopla statements in terms of
execution paths, i.e.\@ sequences of model configurations, because
execution paths and runs of models are of concern to the model checker.
A~model in Remopla can contain both finite and infinite runs.  The way the
model checker understands them depends on the task it is carrying out.

The finiteness of runs does not really matter concerning reachability
analysis. A path leading to any reachable model configuration is always
finite and vice versa. One just has to be careful not to terminate
execution paths by mistake.

On the other hand, the semantics of LTL is defined over infinite runs only.
By default, the model checker ignores finite runs during verification of
LTL properties for reasons discussed below. However, the model checker also
offers a mode in which finite runs are turned into infinite ones by
appending an infinite loop to them.

With LTL model checking in mind, models in Remopla are usually designed to
have infinite runs. Even models of finite computation processes usually
contain explicit infinite loops to which control flow moves after the
computation.

Finite runs are usually introduced into a model by Remopla statements the
semantics of which include termination of particular execution paths in the
sense that the statements do not define the next configuration for a given
one. The termination is either explicit or implicit. The explicit
termination is used to cut off unwanted execution paths based on
a user-defined condition. The implicit termination cuts off execution paths
on which a ``run-time error'' occurs. The errors namely include division by
zero or value out of range. 

Expectedly, implicitly terminated paths start with invalid input data so
it is perfectly safe to terminate them and ignore them for the model
checking. However, it is quite easy to cut off all execution paths by
mistake which leads to meaningless results of model checking.  That is why
the model checker offers the second mode in which finite runs are not
ignored. We pay extra attention to the rules for implicit termination of
execution paths throughout this document.

For an example of implicit termination, consider sample
code~\ref{rem:termination}. The local variable \verb|n| of module
\verb|main| is declared to be a 4-bit unsigned integer so its value can
range from~0 to~15. All execution paths of the model (which differ only in
the initial value of the variable~\verb|n|) start with a call to the
module \verb|main| and try to carry out the assignment at
line~\ref{rem:termination:assgn}.  However, the assignment cannot proceed
because the value is out of range of the variable and the model checker
aborts the execution paths. Because there is no execution path left then,
the analysis never gets to line~\ref{rem:termination:skip}.

\begin{SampleCode}
\begin{RemoplaCode}
    init main;
    
    module void main () {
        int n(4);
        n = 16;\label{rem:termination:assgn}
        # the next line is not reachable
        "not_reachable":  goto "not_reachable";\label{rem:termination:skip} 
    }
\end{RemoplaCode}
\caption{Termination of Execution Paths
(\texttt{termination.rem})\label{rem:termination}}
\end{SampleCode}


\section{Notation}
This document gives a terse description of the syntax and semantics of the
language by explaining its grammar in Backus-Naur form.
The description is accompanied with sample codes that
demonstrate the language concepts. These sample codes also
included in the Moped distribution.

The notation we will use for the grammar is as follows.  \emph{Terminals\/}
are set in typewriter typeface. \emph{Non-terminals\/} are set in roman
typeface and are enclosed in $\langle\,\rangle$. The notation also includes
standard operators of BNF as listed below.
\begin{tabbing}
\hskip 4em \= \\\kill
\zeromore{$x$}              \> for zero ore more repetitions of $x$ \\
\onemore{$x$}               \> for one or more repetitions of $x$ \\
\zeromore{$x$\texttt{,}}    \> for zero or more comma-separated instances of $x$ \\
\onemore{$x$\texttt{,}}     \> for one or more comma-separated instances of $x$ \\
$x$ \bnfor $y$              \> a choice of $x$ or $y$ \\
\optional{$x$}              \> optional (zero or one instance of) $x$ \\
\end{tabbing}

%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Language Overview\label{s:overview}}

The Remopla language is similar to other modern programming languages. A model
in Remopla consists of definitions of constants, declarations of data types
and variables, module definitions and statements.

Constants, types, variables, modules, labels of statements and elements of
enumerated data types are named by \emph{identifiers}. An identifier is any
non-empty string of alpha\-numeric characters and underscores starting with
a letter. The
meta-rules use a regular expression syntax that represent lexical elements
of the language: identifiers and positive integers.

\begin{bnfgrammar}
[identifier]        \is [a-zA-Z]\zeromore{[a-zA-Z0-9_]} \\
[literal number]    \is \onemore{[0-9]} \\
\end{bnfgrammar}

Some identifiers are reserved as keywords. Here is the list of all keywords
in Remopla.

\begin{tabbing}
\qquad \= \\\kill
Keywords for data types:\\
    \> \verb|bool|, \verb|int|, \verb|struct|, \verb|enum|, \verb|void|\\
Keywords for special values and constants:\\
    \> \verb|undef|, \verb|false|, \verb|true|, \verb|DEFAULT_INT_BITS|\\
Keywords for statements:\\
    \> \verb|skip|, \verb|if|, \verb|fi|, \verb|do|, \verb|od|, \verb|else|, \verb|break|, \verb|goto|, \verb|return|\\
Other keywords:\\
    \> \verb|A|, \verb|E|, \verb|define|, \verb|init|, \verb|module|\\
\end{tabbing}

The rules governing name spaces of identifiers are rather complex. To stay
on the safe side, one should not use a single identifier to denote two
different entities. For instance, using an identifier for a constant and
anything else would produce a syntax error. Using an identifier as a module
name and as a label would work just fine but the semantics would differ
from what one might have expected.
%% TODO:
%% The true rules are not explained here because no clear explanation
%% exists. The rules should be be stated first and the parser should be
%% altered to fit them afterwards.
%%
%% However, more details could be given concerning names of variables:
%% global and local variables, formal parameters, quantified variables,
%% inner variables of a structure. 
%%
%% Hint: boolean variables have been observed to mess things up.

Remopla is a \emph{case sensitive} language. The case matters for both
keywords and identifiers.

\emph{Comments\/} in Remopla are line-oriented. Everything in a line
starting from the character \verb|#| or the sequence of characters
\verb|//| is ignored up to the end of the line by the parser as a comment.


%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Model Structure\label{s:model}}

Every model in Remopla has to follow the structure given in the production
rule of <model>. A simple example of the structure is given in sample
code~\ref{rem:simplest}.

\begin{bnfgrammar}
[model] \is \zeromore{<constant definition>}
            \zeromore{<global declaration>}
            <initial configuration>
            \onemore{<module or statement>}
            \\
[global declaration] \is <enum declaration> \or <struct declaration>
    \or <variable declaration>
    \or <module declaration>
    \\
[module or statement] \is <statement> \or <module definition>\\
\end{bnfgrammar}

\emph{Constant definitions\/} can only appear at the very beginning of
a Remopla code. They are not allowed anywhere else.  See
section~\ref{s:constants} for details regarding constant definitions.

\emph{Global declarations\/} stand for type declarations, module
declarations and declarations of global variables. Again, these
declarations cannot be placed anywhere else. Type declarations and
declarations of variables are covered in section~\ref{s:data}. See
section~\ref{s:modules} for more information on module declarations.

\emph{Initial configuration\/} can be thought of as the last global
declaration---it is mandatory for every model and it separates the section
of global declarations from the model body.  The declaration specifies the
initial configuration of the model. The details are given in
section~\ref{s:init}.

\emph{Model body\/} consists of statements and module definitions
implementing the behaviour of the model. The statements are usually
(but not necessarily) organized in modules. Stand-alone statements are
commonly used for infinite labeled loops that explicitly make finite
execution paths infinite. Line~\ref{rem:simplest:ok} of sample
code~\ref{rem:simplest} demonstrates such a loop.

\begin{SampleCode}
\begin{RemoplaCode}
    # constant definitions
    define DEFAULT_INT_BITS 4

    # global declarations
    module void main();

    # initial configuration
    init main;

    # model body

    "ok": goto "ok";\label{rem:simplest:ok}

    module void main () {
        goto "ok";
    }
\end{RemoplaCode}
\caption{The Simplest Model (\texttt{simplest.rem})\label{rem:simplest}}
\end{SampleCode}

%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Constant Definitions\label{s:constants}}

A constant in Remopla is a symbolic name for a non-negative integer. The
primary use of constants is to parametrize models in the sense that
a Remopla code can implement many instances of a problem depending on the
values of constants. All constants must be defined at the
very beginning of the model. The syntax of the constant definition is
governed by the following rule.

\begin{bnfgrammar}
[constant definition] \is define <constant> <cnst expr> \\
[constant] \is <identifier> \\
\end{bnfgrammar}

The second argument of the definition must be a constant integer expression
(see section~\ref{s:expr:int}), i.e.\@ an integer expression that combines
numbers and previously defined constants only.  A constant definition is
lexically terminated either by the next constant definition or by any
global declaration including the declaration of the initial configuration.

\subsection{Internal Constants\label{s:constants:internal}}

Internal constants parametrize the model checking process.  Regarding
syntax, internal constants are keywords which can be used in the <constant
definition> rule in place of <constant>. They cannot be used anywhere else.

There is only one internal constant at the moment but more of them may
be introduced in future versions. Currently, the only internal constant
is \verb|DEFAULT_INT_BITS| and it does exactly what the name
suggests: it sets the default bit size of integers (see
section~\ref{s:data:int}). For instance, the default bit size of integers
in sample code~\ref{rem:simplest} would be~four.  The default bit size of
variables and return values of modules can be overridden in declarations.

%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Data Types and Variable Declarations\label{s:data}}

This section concerns declarations of data types and variables. Formal
parameters and return values of modules are treated in
section~\ref{s:modules}.

The Remopla language supports boolean data type, unsigned integers
of a limited range, enumerated data types and structured data types.
A variable of any of these types can be declared as a simple variable,
one-dimensional array or two-dimensional array. The syntax of regular
variable declarations is given by the production rule of <variable
declaration>. Variables of enumerated and structured data types can also be
declared within the type declarations (see subsections \ref{s:data:enum}
and \ref{s:data:struct}).

\begin{bnfgrammar}
[variable declaration] \is bool \onemore{<variable spec>,} ;
    \or int \onemore{<int variable spec>,} ;
    \or enum <type name> \onemore{<variable spec>,} ;
    \or struct <type name> \onemore{<variable spec>,} ;
    \\
[variable spec] \is <var name>\optional{[<dimen>]}\optional{[<dimen>]}\\
[int variable spec] \is <variable spec>\optional{(<cnst expr>)}\\
[dimen] \is <cnst expr> \or <cnst expr>,<cnst expr> \\
[type name] \is <identifier> \\
[var name] \is <identifier> \\
\end{bnfgrammar}

The <type name> is an identifier which refers to a previously declared
enumerated or structured data type.

The only mandatory part of a variable specification is the identifier <var
name> which names the variable. The name of an array variable is followed
by bracketed specification of array dimensions. Both simple and array
integer variables can also be followed by parenthesized bit size of the
variable and elements of the array, respectively, which overrides the
default bit size from \verb|DEFAULT_INT_BITS|.

% Todo: Does this still belong to declarations? Much of it is
%	explained in Section 6.3.

Access to variables is denoted by <variable> in the grammar rules.  The
usage of a variable depends on its declaration and is summarized by the
following production rule. The first part of the rule gives syntax for
common variables, the second part gives syntax for inner variables of
structures. The optional <array idx> gives syntax for referencing elements
of one- and two-dimensional arrays. 

\begin{bnfgrammar}
[variable] \is <var name>\optional{<array idx>}
    \or <var name>\optional{<array idx>}.<var name>\optional{<array idx>}
    \\
[array idx] \is [<int expr>]\optional{[<int expr>]} \\
<var name> \is <identifier> \\
\end{bnfgrammar}

%%%%%%%%%%%%%%%%
\subsection{Arrays}

One-dimensional and two-dimensional array variables are declared by adding
one and two dimension specifications to the variable identifier,
respectively. A dimension specification has two forms. 

In the first form, the dimension specification consists of a single
constant integer expression. Elements of the array in the respective
dimension are indexed from~$0$ to $n-1$ where $n$ is the value of the
expression. 

In the second form, the dimension specification consists of two
comma-separated constant integer expressions where the first expression
must be lower than or equal to the second one. Elements of the array in the
respective dimension are indexed from $p$ to $q$ where  $p$ and $q$ are the
values of the first and the second expression, respectively.

% Todo: This seems to be at odds with the above declaration.

Note that arrays are strictly limited to the dimension of two. It is not
possible to acquire arrays of more dimensions by constructing arrays of
arrays.

%%%%%%%%%%%%%%%%
\subsection{Booleans\label{s:data:bool}}

%% TODO: add a reference to section on assignments to boolean variables?
The value of a boolean variable can be either \verb|true| or \verb|false|.
Boolean variables and the two keywords form the atomic boolean expressions
from which compound ones can be built up (see section~\ref{s:expr:bool}).
For sample declarations and usage, consider the following lines.

\begin{RemoplaSnippet}
    bool cnd;
    bool b1[0,3], b2[4];
    # sample usage
    cnd = cnd || (b1[0] && b2[3]);
\end{RemoplaSnippet}

Arrays \verb|b1| and \verb|b2| have the same range of indices.
They both have four boolean elements indexed from~$0$ to~$3$
in a single dimension.

%%%%%%%%%%%%%%%%
\subsection{Integers\label{s:data:int}}

Integer variables in Remopla can store unsigned integer values of a limited
range. The values are stored as bit arrays where the least significant
bit is the rightmost one. Every integer variable must be given its bit
size, i.e.\@ the length of the bit array storing its value. Assuming that
the bit size of a variable is~$n$, the value of the variable can range
from~$0$ to~$2^n-1$. 

Internal constant \verb|DEFAULT_INT_BITS| (see
section~\ref{s:constants:internal}) can be set to specify the default bit
size of integer variables. The default value can be overridden by optional
parenthesized constant integer expressions specifying the bit sizes for
individual variables in variable declarations. Note, that it is an error if
neither the default bit size is given nor is the bit size specified
explicitly for each integer variable.

For instance, consider the next few lines of Remopla code. Variable
\verb|area| has bit size~8, both of variables \verb|width| and
\verb|height| have bit size~4.  Variable \verb|m1| is a $5\times 2$ array
with elements indexed from~$0$ to~$4$ in one dimension and from~$2$ to~$3$
in the other.  The elements are 4-bit integers. Variable \verb|m2| is
a one-dimensional array with ten elements indexed from~$0$ to~$9$. The
elements are 3-bit integers.

\begin{RemoplaSnippet}
    define DEFAULT_INT_BITS 4
    int area(8), width, height;
    int m1[0,4][2,3], m2[10](3);
    # sample usage
    area = width*height;
    m1[1][2] = 2*m2[9];
\end{RemoplaSnippet}

%% TODO: add a reference to section on assignments to integer variables?

%%%%%%%%%%%%%%%%
\subsection{Enumerations\label{s:data:enum}}

In general, an enumeration is a finite sequence of identifiers. The syntax
of an enumerated data type declaration is described by the following rules.

\begin{bnfgrammar}
[enum declaration] \is  enum \optional{<type name>} \{
                            \onemore{<enum element>,}
                        \} \zeromore{<variable spec>,} ;
                        \\
[enum element] \is <identifier> \\
<type name> \is <identifier> \\
<variable spec> \is <var name>\optional{[<dimen>]}\optional{[<dimen>]}\\
<var name> \is <identifier> \\
\end{bnfgrammar}

The optional element <type name> is an identifier denoting the declared
type. Naming the new type makes it possible to declare local module
variables, module parameters and modules with return values of that type.
Declarations of global variables can be included directly into the type
declaration.

The following declaration gives an example of an enumerated data type.
Because the enumerated type is not given a name, one would have to exploit
the implementation to declare more variables of the same data type.

\begin{RemoplaSnippet}
    enum {
        s_start, s_accept, s_deny 
    } state;
    # sample usage
    state = s_start;
\end{RemoplaSnippet}

The implementation of enumerated data types is based on integers. Elements
of an enumerated set are numbered from zero and behave exactly the same as
constants. It follows that a single identifier cannot name elements of two
enumerated types. The identifier is bound to an integer at the first
occurrence and the second occurrence would produce a syntax error. It also
follows that enumerated types of the same number of elements are
equivalent. The elements from the above example are equivalent to constant
definitions as follows.

\begin{RemoplaSnippet}
    define s_start  0
    define s_accept 1
    define s_deny   2
\end{RemoplaSnippet}

% TODO: I don't understand the following sentence. - Stefan
However, the constant definitions does not allow to declare any equivalent
to the variable \verb|state|. The behaviour of an uninitialized common
2-bit integer variable differs from that of the variable \verb|state|. The
former can take value 3 whereas the latter cannot. See also the special
\verb|undef| value in section~\ref{s:assignments}.


%%%%%%%%%%%%%%%%
\subsection{Structures\label{s:data:struct}}

Simple variables and arrays of integers and booleans can form a single data
type---a structured data type. The declaration syntax of a new structured data
type is governed by the following rules. Similarly to enumerated data
types, <type name> is optional and variable declarations can be embedded
into the type declaration.
%% TODO: why not enums? because they segfault. see remy-struct-segfault.rem

\begin{bnfgrammar}
[struct declaration] \is    struct \optional{<type name>} \{
                                \onemore{<struct member>}
                            \} \zeromore{<variable spec>,} ;
                            \\
[struct member] \is bool \onemore{<variable spec>,} ;
    \or int \onemore{<int variable spec>} ;
    \\
<type name> \is <identifier> \\
<variable spec> \is <var name>\optional{[<dimen>]}\optional{[<dimen>]}\\
<int variable spec> \is <variable spec>\optional{(<cnst expr>)}\\
<var name> \is <identifier> \\
\end{bnfgrammar}

Note that it is not possible to use structured data type to acquire more
than two-dimensional arrays. If a structured data type contains an array,
it is not allowed to declare an array with elements of that type. If an
array with elements of a structured data type is required, the structure
must contain no arrays.

The main use of variables of structured data types is to make
passing local data to and from modules easier (see
section~\ref{s:modules}). Variables of structured data types cannot be used
anywhere else. The inner parts of structured variables can be used as
ordinary variables.

\begin{RemoplaSnippet}
    define DEFAULT_INT_BITS 4
    
    struct rectangle {
        int width, height, area(8);
        bool side_property[4];
    };
    struct rectangle rct;
    # sample usage
    rct.width = 3;
    rct.height = 4;
    rct.side_property[3] = true;
\end{RemoplaSnippet}

The sample code above declares a new structured data type named
\verb|rectangle|. It also declares structured variable \verb|rct| and shows
the way the inner parts of the structured variable can be accessed.


%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Initial Configuration\label{s:init}}

Global declarations in a model are always terminated by a mandatory
declaration of initial configuration the syntax of which is given by the
following rule.
\begin{bnfgrammar}
    [initial configuration] \is init <module name>; \or init <label>; \\
<module name>   \is <identifier> \\
<label>         \is <identifier> \\
\end{bnfgrammar}

The declaration determines a point in the model from which the model
execution paths start. For a label, they simply start with the labeled
statement (see section~\ref{s:statements}). For a module name, all
execution paths start by a call to the module (see section~\ref{s:call}).

Initial values of variables are not specified by this declaration. It
effectively means that the declaration specifies a set of initial
configurations, one for each combination of values that fit into the ranges
of individual variables in the lexical scope of the starting point.  An
execution path of the model can start from any of the initial
configurations.

The lexical scope of a labeled statement outside a module includes global
variables only. The lexical scope of a module name includes global
variables and module parameters; local variables of the module are
non-initialized by the semantics of a module call (see
section~\ref{s:call}). Finally, the lexical scope of a labeled statement
inside a module includes global variables, module parameters and local
variables of the module. However, one should avoid this option.

For example, consider sample code~\ref{rem:quantbool} on
page~\pageref{rem:quantbool}. The array is not initialized. The label
"labA" is reachable because \verb|a[0]| can be non-zero. Because it can also be
zero, the label "labB" is reachable, too.


%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Expressions\label{s:expr}}

The Remopla language distinguishes three types of expressions: constant
integer expressions, general integer expressions and boolean expressions.
The syntax of all the three kinds of expressions is defined by the
following rules. The following subsections treat details regarding each
one of them.

\begin{bnfgrammar}
[cnst expr] \is <literal number> \or <constant>
    \or <cnst expr> <integer binop> <cnst expr>
    \or ( <cnst expr> )
    \\
[int expr] \is <literal number> \or <constant> \or <variable>
    \or <int expr> <integer binop> <int expr>
    \or ( <int expr> )
    \\
[bool expr] \is true \or false \or <variable>
    \or <int expr> <integer binrel> <int expr>
    \or ! <bool expr>
    \or A <var name> (<cnst expr>,<cnst expr>) <bool expr>
    \or E <var name> (<cnst expr>,<cnst expr>) <bool expr>
    \or <bool expr> <boolean binop> <bool expr>
    \or ( <bool expr> )
    \\
[integer binop] \is * \or / \or + \or - \or \bitlsh \or \bitrsh \or \bitand \or \bitor \or \bitxor \\
[integer binrel] \is \remlt \or \remle \or \remeq \or \remne \or \remge \or \remgt \\
[boolean binop] \is \booland \or \boolor \or \boolxor \or \booleq \\
<constant> \is <identifier> \\
<variable> \is <var name>\optional{<array idx>}
    \or <var name>\optional{<array idx>}.<var name>\optional{<array idx>}
    \\
<array idx> \is [<int expr>]\optional{[<int expr>]} \\
<var name> \is <identifier> \\
\end{bnfgrammar}

The integer operators are multiplication, division, addition, subtraction,
shift left, shift right, bitwise conjunction, bitwise disjunction and
exclusive bitwise disjunction, respectively. The boolean operators are
conjunction, disjunction, exclusive disjunction and logical equivalence,
respectively.


%%%%%%%%%%%%%%%%
\subsection{Constant Integer Expressions}

Constant integer expressions just provide syntactic sugar---a more general
way how to write numbers. These expressions are evaluated at parse time
Because of this, division by zero in a constant integer
expression is reported as a syntax error by the parser and so is any negative
value of an expression.


%%%%%%%%%%%%%%%%
\subsection{General Integer Expressions\label{s:expr:int}}

The syntax of general integer expressions of Remopla is very similar to
common programming languages but the semantics differs. Models in Remopla
do not raise errors when an integer expression cannot be evaluated for some
reason. The behaviour in these cases depends on the context of the
expression.

In general, the evaluation of a general integer expression is best viewed
as a relation which relates a combination of values of variables present in
the expression to a result of the expression---an unlimited integer. It is
the context of the expression which may pose finite bounds on the result. If
the expression does not evaluate to an integer, the corresponding input
values relate to nothing.

The cases in which an expression does not evaluate to an integer namely include
division by zero and an out of range index of an array element at any level
of nesting---the index of an array element can be another integer expression
involving a reference to another array element etc.

Execution paths in which an integer expression cannot be evaluated are
terminated in most cases. The only exception is an integer expressions as
a part of an atomic boolean expression---the boolean expression is
considered false if an integer expression it contains cannot be evaluated.
See subsection~\ref{s:expr:bool} for more details.

The statements that implicitly terminate execution paths in which an
integer expression cannot be evaluated include assignments, return
statements returning non-boolean value and module calls with non-boolean
parameters (see sections~\ref{s:assignments}, \ref{s:return}
and~\ref{s:call}).


%%%%%%%%%%%%%%%%
\subsection{Boolean Expressions\label{s:expr:bool}}

The primary use of boolean expressions in Remopla is to guard clauses of
conditionals and loops (see section~\ref{s:ifloop}). Of course, the
expressions can also be used in assignments to boolean variables (see
sections~\ref{s:data:bool} and~\ref{s:assignments}). 

The syntax of boolean expressions is similar to common programming
languages. Standard binary logical connectives and the negation operator
(the exclamation mark \verb|!|) are available. Moreover, there are
universal quantifier \verb|A| and existential quantifier \verb|E| which
require more explanation.

Both quantifiers declare an identifier as a read-only integer variable and
its range that can be used inside the quantified expression only.  A universally
quantified expression holds if and only if the inner expression holds for
every value of the quantified variable. An existentially quantified
expression holds if and only if the inner expression holds for at least one
value of the quantified variable.

The quantified expressions can be very handy when it comes to tests on
arrays. Sample code~\ref{rem:quantbool} demonstrates usage of quantified
expressions. The two boolean expressions in the example are equivalent:
they check if there is a non-zero element in the array~\verb|a|. Because the
array is not initialized, both labels are reachable.

\begin{SampleCode}
\begin{RemoplaCode}
    int a\lbrk4\rbrk(4);

    init main;

    module void main () {
        if
        :: ! A i (0,3) a\lbrk[]i\rbrk == 0 -> goto "labA";
        ::   E i (0,3) a\lbrk[]i\rbrk != 0 -> goto "labA";
        :: else  -> goto "labB";
        fi;
    }

    "labA": goto "labA";
    "labB": goto "labB";
\end{RemoplaCode}
\caption{Quantified Boolean Expressions
(\texttt{quant-bool.rem})\label{rem:quantbool}}
\end{SampleCode}

A boolean expression is always evaluated either to true or false because
it is so for all atomic expressions. If an atomic expression (a boolean
variable or an integer comparison) involves an integer expression that
cannot be evaluated or an out of range index to an array element, the
atomic expression is considered false. See also section~\ref{s:expr:int}.

Note that there are no bounds on the values being compared in an integer
comparison.  Again, the comparison is best seen as a relation on involved
variables.  The comparison yields true if the current values of variables
belong to the relation and false otherwise. Size of no subexpressions but
array indices matter. For instance, \verb|-1==-1| yields true whereas
\verb|-1==-2| yields false.


%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Statements\label{s:statements}}

The following rules list all types of statements in Remopla.  We are not
going to a give formal semantics of the statements. Instead, we will give
an informal description of the effects of the statements
on execution paths of a model. Recall the discussion of implicit
termination of execution paths in section~\ref{s:modelchecking} and
evaluation of integer and boolean expressions in section~\ref{s:expr}.

\begin{bnfgrammar}
[statement] \is \optional{<label>:} <real statement> \\
[real statement] \is <assignments>
    \or <skip statement>
    \or <goto statement>
    \or <break statement>
    \or <if statement>
    \or <do statement>
    \or <return statement>
    \or <call statement>
    \\
[label] \is <identifier> \\
\end{bnfgrammar}

Any statement can be labeled with an identifier. Labels must be unique
across the model. Labeling a statement makes it possible to bring control
flow to that statement by a go-to statement and the declaration of initial
configurations (see sections~\ref{s:goto} and~\ref{s:init}, respectively)
and to query reachability of the label. Labels also form a subset of atomic
propositions of LTL formulae over the model at hand.


%%%%%%%%%%%%%%%%
\subsection{Assignments\label{s:assignments}}

\begin{bnfgrammar}
[assignments] \is \onemore{<assignment>,};\\
[assignment] \is    \optional{<quantify>} <variable> = undef
    \or <variable> = <variable>
    \or \optional{<quantify>} <variable> = <int expr>
    \or \optional{<quantify>} <variable> = <bool expr>
    \\
[quantify] \is A <var name> (<cnst expr>,<cnst expr>)
%    \or E <var name> (<cnst expr>,<cnst expr>)
    \\
<variable> \is <var name>\optional{<array idx>}
    \or <var name>\optional{<array idx>}.<var name>\optional{<array idx>}
    \\
<array idx> \is [<int expr>]\optional{[<int expr>]} \\
<var name> \is <identifier> \\
\end{bnfgrammar}
%% TODO:
%% Existential quantification is also allowed by syntax but the intended
%% semantics is not clear. It should be fixed before mentioning it here. 

Assignments are usually at the core of any model. A variable of any given
type receive the value of another variable of the same type and the
same dimensions for an array variable. Simple integer and boolean variables
can be assigned the result of an integer and boolean expression,
respectively. 

Multiple assignments can be put in parallel. A parallel assignment
consisting of any number of individual assignments works as a single
relation which relates current values of variables in expressions at the
right-hand sides to new values of variables at the left-hand sides. 

An assignment can be universally quantified using the~\verb|A| keyword. The
quantification declares a read-only integer variable and its range. The
variable can be used in the assignment. Such an assignment is equivalent to
a parallel assignment which contains one instance of the assignment for
each value of the quantified variable from the given range. It is very
handy in operations with arrays. For instance, the following code
initializes an array to zeros.
\begin{RemoplaSnippet}
    define ARRLNG 5
    int arr[ARRLNG](2);
    A i (0,ARRLNG-1) arr[i] = 0;
\end{RemoplaSnippet}

\subsubsection{Unsetting Variables}

The special \verb|undef| value ``unsets a variable'', i.e.\ it gives
the variable a non-deterministic value within its range, effectively
making it 
non-initialized like before the first assignment to it. The assignment
effectively splits each execution path into several ones, one for every
possible value of the unset variable. 

There are just two values for a boolean variable, \verb|true| and
\verb|false|. The number of possible values of a simple integer variable
depends on its bit size---all values from the range are considered. For
a variable of an enumerated data type, there is one path for every element
of the enumerated set. Concerning arrays and structures, unsetting is
applied to all array elements and inner variables of the
structure, respectively.

\subsubsection{Implicit Termination of Execution Paths}

There are three independent conditions under which execution paths are
terminated by assignments.

Assignments implicitly terminate all execution paths in which the left-hand
side of the assignment contains an integer expression or an out of range
index of an array element at any level of nesting. Non-existent element of
an array is not a valid variable for assignment.

Assignments to integer variables implicitly terminate all execution paths
in which the integer expression on the right-hand side yields a value which
is out of the variable range or if the expression does not evaluate at all
(see section~\ref{s:expr:int}).  Neither overflow nor underflow can happen.

A parallel assignment containing multiple assignments to the same variable
terminates all execution paths except for those in which the variable
receives the same value in all assignments. For instance, consider the following
lines of Remopla code. The first line is equivalent to the simple assignment
\verb|n=1|. The two assignments in the second line never assign the same
value to~\verb|n| so all execution paths are terminated.
\begin{RemoplaSnippet}
    n=1, n=undef;
    n=1, n=2;
\end{RemoplaSnippet}


%%%%%%%%%%%%%%%%
\subsection{Skip Statement\label{s:skip}}

\begin{bnfgrammar}
[skip statement] \is skip \optional{(<bool expr>)}; \\
\end{bnfgrammar}

The skip statement is an extended version of skip statements from common
programming languages whose primary use is to fulfill syntax
requirements of other statements. The skip statement in Remopla can do
more.

The statement takes one argument---a parenthesized boolean expression. It
continues to the next statement for exactly those execution
paths in which the expression holds. It aborts the other paths. The
argument may be omitted in which case true is assumed---no path is
terminated.

For example, the label "lbl" cannot be reached by executing the first skip
statement in the following line of Remopla code.
\begin{RemoplaSnippet}
    skip false; "lbl": skip;
\end{RemoplaSnippet}


%%%%%%%%%%%%%%%%
\subsection{Go-To Statement\label{s:goto}}

\begin{bnfgrammar}
[goto statement] \is goto <label>; \\
\end{bnfgrammar}

The go-to statement moves control flow to the given label. The statement
always preserves global data and the depth of the call stack. However, the
effects on the context on the top of the stack, and hence local data, vary
depending on the usage.

Jumps are usually used within the same lexical scope, i.e.\@ both the go-to
statement and the label are outside modules or in a single module. The jump
preserves the context including any local data then.

If a jump spans across more lexical scopes, the current context (that of
the go-to statement) is replaced by a new one fitting the jump destination.
Local variables of the new context are non-initialized after the jump which
effectively means all possibilities are examined. However, this practice is
not recommended except for jumps to infinite go-to loops
(see sample code~\ref{rem:simplest}).


%%%%%%%%%%%%%%%%
\subsection{Break Statement\label{s:break}}

\begin{bnfgrammar}
[break statement] \is break; \\
\end{bnfgrammar}

Outside of a loop or a conditional, the break statement does nothing. Within
a clause of a loop or a conditional, it terminates the innermost loop or
conditional and brings control to the lexically next statement after the
terminated one.



%%%%%%%%%%%%%%%%
\subsection{Conditionals and Loops\label{s:ifloop}}

\begin{bnfgrammar}
[if statement] \is  if
                    \onemore{<guarded clause>}
                    \optional{:: else -\> \onemore{<statement>}}
                    fi; \\
[do statement] \is  do
                    \onemore{<guarded clause>}
                    \optional{:: else -\> \onemore{<statement>}}
                    od; \\
[guarded clause] \is :: <bool expr> -\> \onemore{<statement>} \\
\end{bnfgrammar}

Conditional and loop statements of Remopla have much in common which is why
this single section concerns them both. Both conditionals and loops
consist of guarded clauses of statements where guards are boolean
expressions (see section~\ref{s:expr:bool}).

When control arrives at the statement, all guards are evaluated first. The
clause that gets control is then chosen non-deterministically among those
clauses whose guards hold. This effectively means there is an
execution path for each of them. If no guard holds and there
is an \verb|else|-clause, control is passed to it. If the
\verb|else|-clause is missing, the statement implicitly terminates all
execution paths that do not satisfy any guard.

The \verb|if|-statement is evaluated only once. The \verb|do|-statement is
evaluated repeatedly until \verb|break| or \verb|goto| occurs (see
sections~\ref{s:goto} and~\ref{s:break}, respectively). The two statements
can terminate the \verb|if|-statement, too.

The semantics of loops and conditionals has several implications on the
implementation of similar statements from common programming languages. For
instance, the label "lbl" is not reachable in the following Remopla code if
\verb|a>=b|.
\begin{RemoplaSnippet}
    if
    :: a<b  -> a=b, b=a;
    fi;
    "lbl": skip;
\end{RemoplaSnippet}

This was probably unintended.  The \verb|else|-clause is required to fix it
as in the following code.
\begin{RemoplaSnippet}
    if
    :: a<b  -> a=b, b=a;
    :: else -> break;
    fi;
    "lbl": skip;
\end{RemoplaSnippet}

Let us present one more example to demonstrate the non-deterministic choice
among satisfied guards. The following \verb|do|-statement will loop until the
execution of the last clause takes place. The value of \verb|i| can be
any of \verb|1|, \verb|2| and \verb|3| then.
\begin{RemoplaSnippet}
    i = 1;
    do
    :: true -> i = 2;
    :: true -> i = 3;
    :: true -> break;
    od;
\end{RemoplaSnippet}


%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\section{Modules\label{s:modules}}

Modules implement the concept of functions and procedures in Remopla.
A~module can take arguments and return a value. A module call can also be
queried for reachability.

The Remopla language contains four distinct constructs concerning modules.
A \emph{module declaration\/} is required if a module is called lexically
before its definition. A \emph{module definition\/} implements the module.
A \emph{module call\/} is used to pass control to a module. Finally, the
\emph{return statement} returns control (and possibly a value) from
a module to its caller.

%%%%%%%%%%%%%%%%
\subsection{Declarations and Definitions\label{s:modules:decl}}

\begin{bnfgrammar}
[module declaration] \is module
                         <return type> <module name> (\zeromore{<parameter>,}); \\
[module definition] \is module
                        <return type> <module name> (\zeromore{<parameter>,}) \{ 
                            \zeromore{<variable declaration>} 
                            \onemore{<statement>}
                        \}\\
[parameter] \is bool <variable spec> \or int <int variable spec>
    \or enum <type name> <variable spec>
    \or struct <type name> <variable spec> \\
[return type] \is void 
    \or int \optional{[<dimen>]}\optional{[<dimen>]}\optional{(<cnst expr>)}
    \or <data type> \optional{[<dimen>]}\optional{[<dimen>]} \\
[data type] \is bool \or enum <type name> \or struct <type name> \\
[module name] \is <identifier> \\
<type name> \is <identifier> \\
<dimen> \is <cnst expr> \or <cnst expr>,<cnst expr> \\
\end{bnfgrammar}

Each module definition starts with a header that specifies the prototype of
the module: name, formal parameters and return type of the module. The name
is an identifier. Formal parameters essentially form a comma-separated list
of variable declarations (see section~\ref{s:data}) where each parameter is
given its type individually. The return type is very similar to the declaration
of a variable, too, the variable name is just omitted. The return type can
also be a special keyword \verb|void| which means that the module has no
return value.

After the header follows the module body: declarations of local variables
and actual statements implementing the module. Declarations of local
variables are exactly the same as declaration of global ones. Local
variables of the same name as global variables are not allowed. 

The prototype of each module must be known prior to a call to the module.
It cannot be satisfied by the order of definitions only if the module calls
form a cycle.  Module declarations in the section of global declarations
(see section~\ref{s:model}) can be used to specify the prototype of modules
prior to any definitions and calls. The declaration consists of the module
header and each declared module must be defined with exactly the same
header in the model later on. 

%%%%%%%%%%%%%%%%
\subsection{Return Statement\label{s:return}}

\begin{bnfgrammar}
[return statement] \is return;
    \or return <bool expr>;
    \or return <int expr>;
    \or return <variable>;
    \\
\end{bnfgrammar}

The return statement can only be used within a module and the form must
match the return type of the module. It terminates execution of the module
and returns control and a value to the caller of the module. It follows
from the syntax that the return value must be stored in a local or a global
variable if the type of the return value is more complex than a simple
integer or boolean value.

A return statement returning a boolean value or no value at all does not
terminate any execution paths implicitly.

Returning an integer value implicitly terminates all execution paths in
which the expression cannot be evaluated. It also terminates the paths in
which the value of the expression does not fit into the bounds of the
return value as given by the module declaration or by the
\verb|DEFAULT_INT_BITS| internal constant.

If the return statement returns a more complex value it must be given in
a variable. The variable given to the return statement can be an array
element. In this case, the return statement implicitly terminates all
execution paths in which the index of the element cannot be evaluated or is
out of range.

%%%%%%%%%%%%%%%%
\subsection{Module Call\label{s:call}}

\begin{bnfgrammar}
[call statement] \is <module call>;
    \or <variable> = <module call>; \\
[module call] \is <module name> (\zeromore{<argument>,}) \\
[argument] \is <variable> \or <int expr> \or <bool expr> \\
\end{bnfgrammar}

Module calls are statements which pass control to a module along with the
actual parameters the module requires. Modules can be called as procedure
and, if they return a value, in an assignment that stores the return value
to a variable. Note that it is not possible to use a module call in an
expression even if it returns simple integer or boolean value. Nor can it
be put in parallel with other assignments and module calls.

The parameters are passed by value and must comply with the module
header. Values of integer and boolean parameters can be given as integer
and boolean expressions, respectively. More complex values must be passed
in a variable. 

Passing parameters by value is essentially equivalent to assignments. The
rules for implicit termination of execution paths are hence the same (see
section~\ref{s:assignments}). Parameters of complex data types can cause
termination of execution paths, similarly to the return statement (see
section~\ref{s:return}) if the index of some array element is invalid.


%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{introduction}

\end{document}



