//	This code copyright (c) by the Grail project.
//	No commercial use permitted without written consent. 
//	November 1994

/***************************************************************************

  File:  classes/fm/minbyp.src
  -----

  Description:
  ------------
    This file contains the definition of the following functions:
      fm<Label>& fm<Label>::min_by_partition()
      void fm<Label>::merge_inverse(set<set<state> >& result, 
                      set<set<state> >& to_do, set<state>& inv)

    min_by_partition is a public member of the template class fm;
    merge_inverse and find_part are protected members (fm is declared 
    in classes/fm/fm.h).

  Revision History:
  -----------------
    The Grail Project               Initial version of source code
    M.Hoeberechts  98/09/10         Added header and comments

 ***************************************************************************/




/***************************************************************************

             fm<Label>& fm<Label>::min_by_partition()

  Description:
    This function is a public member of the template class fm (declared in
    classes/re/fm.h).  Minimizes the fm using Hopcroft's partition 
    algorithm.  The fm is first reduced to only the reachable states.
    Error messages are printed on the standard output stream if an
    aspect of the minimization fails.  The function returns a reference
    to this fm.

    This function can be called in the following way:
      this_fm.min_by_partition();

  Parameters:  none

  Return Value:
    fm<Label>& - a reference to this fm
  
 ***************************************************************************/

template <class Label>
fm<Label>&
fm<Label>::min_by_partition()
{
	fm<Label>		m;
	int			i;
	int			j;
	state			s1;
	state			s2;
	set<state>		complement;
	set<state>		current;
	set<state>		inverse;
	set<set<state> >	fpart;
	set<set<state> >	part;
	fm<Label>		temp;
	inst<Label>		t;
	set<Label>		alphabet;

	// reduce automaton to only the reachable states
	reachable_fm();
	reverse();
	reachable_fm();
	reverse();

	// collect alphabet
	labels(alphabet);

	// put the partitions into the partition list
	states(inverse);
	fpart.clear();
	part.clear();
	s1 = 5;
	fpart = final_states;
	part = final_states;
	inverse -= final_states;
	if (inverse.size() != 0)
	{
		fpart += inverse;
		part += inverse;
	}

	// analyze each partition element in the list
	while (part.size() > 0)
	{
		current = part[0];
		part -= current;

		// for each label, find inverse
		for (j=0; j<alphabet.size(); ++j)
		{
			inverse.clear();
			for (i=0; i<current.size(); ++i)
			{
				select(alphabet[j], current[i], SINK, temp);
				inverse += temp.sources(complement);
			}

			// if no inverse, go on to next label
			if (inverse.size() == 0)
				continue;

			// otherwise, merge the inverse
			merge_inverse(fpart, part, inverse);
		}
	}

	for (i=0; i<size(); ++i)
	{
		inst<Label>	t;

		s1 = find_part(fpart, arcs[i].get_source());
		if (s1.is_null())
		{
			cout << "can't find source " << arcs[i].get_source() << " in " << fpart;
		}
		s2 = find_part(fpart, arcs[i].get_sink());
		if (s2.is_null())
		{
			cout << "can't find sink " << arcs[i].get_sink() << " in " << fpart;
		}
		if (s2.is_null() || s1.is_null())
			continue;	
		t.assign(s1, arcs[i].get_label(), s2);
		m.add_instruction(t);
	}

	for (i=0; i<final_states.size(); ++i)
	{
		s1 = find_part(fpart, final_states[i]);
		if (s1.is_null())
		{
			cout << " can't find final state " << final_states[i] << endl;
			continue;
		}
		m.final_states += s1;
	}

	for (i=0; i<start_states.size(); ++i)
	{
		s1 = find_part(fpart, start_states[i]);
		if (s1.is_null())
		{
			cout << " can't find start state " << start_states[i] << endl;
			continue;
		}
		m.start_states += s1;
	}

	*this = m;
	return *this;
}


/***************************************************************************

          void fm<Label>::merge_inverse(set<set<state> >& result, 
                  set<set<state> >& to_do, set<state>& inv)

  Description:
    This function is a protected member of the template class fm (declared
    in classes/re/fm.h).

    This function can be called in the following way:
      this_fm.merge_inverse(result, to_do, inv);

  Parameters:
    set<set<state> >& result
    set<set<state> >& to_do
    set<state>& inv

  Return Value:  none
  
 ***************************************************************************/

template <class Label>
void
fm<Label>::merge_inverse(set<set<state> >& result, set<set<state> >& to_do, 
				set<state>& inv)
{
	set<state>	temp;
	set<state>	temp2;

	for (int i=0; i<result.size(); ++i)
	{
		// if the inverse is the current element, you're done
		if (result[i] == inv)
			return;

		// check for an intersection with the current element
		temp.intersect(result[i], inv);

		// if no intersection, continue
		if (temp.size() == 0)
			continue;		

		// if the inverse is properly contained in the 
		// current element
		if (temp == inv)
		{
			result[i] -= inv;
			to_do += inv;
			result += inv;
			return;
		}

		if (temp == result[i])
		{
			inv -= result[i];
			merge_inverse(result, to_do, inv);
			return;
		}

		result[i] -= temp;
		inv -= temp;
		to_do += temp;
		result += temp;
		merge_inverse(result, to_do, inv);
		return;
	}
}



/***************************************************************************

     int fm<Label>::find_part(set<set<state> >& partition, state s)

  Description:
    This function is a public member of the template class fm (declared in
    classes/re/fm.h).  Determines the partition in which the parameter state
    can be found.  The function returns the index of the partition if the
    state is found, -5 otherwise.

    This function can be called in the following way:
      result = this_fm.find_part(partition, state_to_find);

  Parameters:
    set<set<state> >& partition - the set of partitions to search
    state s - the state to find

  Return Value:
    int - the index of the partition if the state is found, -5 otherwise
  
 ***************************************************************************/

template <class Label>
int
fm<Label>::find_part(set<set<state> >& partition, state s)
{
	for (int i=0; i<partition.size(); ++i)
		if ((partition[i]).member(s) >= 0)
			return i;

	return -5;
}
