//	This code copyright (c) by the Grail project.
//	No commercial use permitted without written consent. 
//	August 1994

/***************************************************************************

  File:  classes/fm/fm.h
  -----

  Description:
  ------------
    This file contains the type defintion for a finite state machine
    template class.  The template parameter specifies the type for the
    instructions on the arcs of the automaton.  This declaration provides
    flexibility because it allows any base type or user defined defined type
    to be specified as the input type for the machine.  For example, an
    fm which accepts alphabetic characters as input could be declared by
    fm<char> whereas a machine which accepts integers could be declaraed
    by fm<int>.

    The internal representation and input/output format of finite state 
    machines in Grail is somewhat different from the usual.  A machine is 
    represented as a set of instructions.  For example, a machine which
    accepts the language ab is specified by:

      (START) |- 0
      0 a 1
      1 b 2
      2 -| (FINAL)

    Each instruction is a triple consisting of a source state, an instruction
    symbol, and the corresponding target state.  The start and final states
    of the machine are indicated by means of special pseudo-instructions,
    whose labels are symbols that can be thought of as end markers on the
    input tape.  The states (START) and (FINAL) are pseudo-states; they
    simply indicate that the other state in the instruction is a start state
    or final state.

    The alphabet of a Grail machine is given implicitly; it is the set of
    symbols which appear in the non-pseudo instructions.  Grail permits
    machines to have multiple start and final states.

    Finite machines inputted to Grail or outputted by its filters will be in
    the above format.  The order of the instructions is arbitrary.  A machine 
    with several start and final states will have a pseudo-instruction for 
    each one:

      0 -| (FINAL)
      1 b 2
      0 a 1
      (START) |- 0
      (START) |- 1
      2 -| (FINAL)

    The internal representation for an automaton consits of a set (non-pseudo)
    instructions, a set of final states and a set of start states.  Member
    functions are provided which allow the union, catanation, complement,
    completion, cross product, reversal, subset construction, and minimization
    of automata.  There are also functions to add or remove instructions, 
    collect the instructions, start states, or final states and to input
    or output the finite machine.


  Revision History:
  -----------------
    The Grail Project               Initial version of source code
    M.Hoeberechts  98/02/04         Added header and comments

 **************************************************************************/


#ifndef		FM_CLASS_DEFINITION

// specification for state role in an instruction
enum { SOURCE, SINK, EITHER };

template <class Label> class fl;

template <class Label>
class fm
{
        friend 
	set<inst<Label> > get_arcs (const fm<Label>& f)
			// returns a copy of the set of arcs in this fm
	  		{ set<inst<Label> > tmp;
	    		tmp = f.arcs;
	    		return tmp;
	   		}


protected:

	int	find_part(set<set<state> >&, state);
		
	int	find_first(const state&) const;
	void	merge_inverse(set<set<state> >&,set<set<state> >&,set<state>&);

	set<inst<Label> >	arcs;		// set of instructions
	set<state>		start_states;	// set of start states
	set<state>		final_states;	// set of final states

	// friend functions

	friend	istream&	
	operator>>(istream&, fm<Label>&);		// stream input

// public functions
public:
 
			fm() { ; }
			// default constructor

			fm(const fm<Label>& x) :
			  arcs(x.arcs), start_states(x.start_states), 
			  final_states(x.final_states) { }
			// copy constructor:  make this fm a copy of the
			//  parameter fm.

			~fm() { ; }		
			// destructor

	fm<Label>&	operator=(const fm<Label>&);
			// assignment:  assign this fm to contain the same set
			//  of instructions and start and final states as
			//  the parameter fm.  Returns a reference to this fm.

	int		operator==(const fm<Label>&) const;	
			// test for equality:  returns 1 if this fm is equal to
			//  the parameter fm (contains the same set of
			//  instructions and start and final states), and 0
			//  otherwise.

	int		operator!=(const fm<Label>& x) const	
			// test for inequality:  returns 1 if this fm is not
			//  equal to the parameter fm (contains a different
			//  set of instructions, start states or final states),
			//  and 0 otherwise.
			{ return *this == x ? 0 : 1; }

	fm<Label>&	operator+=(const fm<Label>&);	// union of fm
	fm<Label>&	operator+=(fm<Label>*);	// union of fm
	fm<Label>&	operator^=(const fm<Label>&);	// catenation
	fm<Label>&	operator-=(const fm<Label>& a);	// delete instructions
	inst<Label>&	operator[](int i) const		// return instruction
			{ return arcs[i]; }
	void		add_instruction(const inst<Label>& i)
			{ arcs += i; }
	void		cartesian(const set<state>&, const set<Label>&, 
				const set<state>&);
	int		canonical_numbering();		// number states
	fm<Label>&	clear() 			// clear contents of fm
			{ arcs.clear(); start_states.clear();
			  final_states.clear(); return *this; }
	void		complement();			// complement the fm
	void		complete();			// complete an fm
	void		cross_product(const fm<Label>&, const fm<Label>);	

	void            dfaunion(const fm<Label>& a, const fm<Label> b);
	fm<Label>&	disjoint_union(const fm<Label>&);
	inline fm<Label>&	disjoint_union(const inst<Label>&);
	fm<Label>&	empty_string_machine();		// create e-machine
	int		enumerate(int, set<string<Label> >&); 
							// generate strings in L
	set<state>&	finals(set<state>& r) const	// all final states
			{ return r=final_states; }
	int		is_complete() const;		// complete ?
	int		is_deterministic() const;	// deterministic ?
	int		is_universal() const;		// universal ?
	set<Label>&	labels(set<Label>&) const;	// all labels
	state		max_state() const;		// maximum state
	int		member_of_language(const string<Label>&, const int) 
						const;	// test membership
	fm<Label>&	min_by_partition();		// minimize machine
	int		number_of_final_states() const
			{ return final_states.size(); }
	int		number_of_labels() const
			{ set<Label> r; return labels(r).size(); }
	int		number_of_start_states() const
			{ return start_states.size(); }
	int		number_of_states() const
			{ set<state> r; return states(r).size(); }
	int		number_of_instructions() const	
			{ return arcs.size(); }
	void		plus();				// ``+'' of fm
	void		reachable_fm();			// reachable sub-fm
	void		reachable_states(set<state>&) const;	
							// reachable states
	void		remove(const state&);		// remove arcs with
							// this state
	void		renumber(int);			// renumber fm
	void		reverse();			// reverse fm
	fm<Label>&	select(const state&, int, fm<Label>&) const;
	fm<Label>&	select(const Label&, fm<Label>&) const;
	fm<Label>&	select(const Label&, const state&, int, 
					fm<Label>&) const;
	void		set_finals(const set<state>& s)
			{ final_states = s; }
	void		set_starts(const set<state>& s)
			{ start_states = s; }
	fm<Label>&	single(const Label&);		// single instruction fm
	set<state>&	sinks(set<state>&) const;	// sinks states of fm
	int		size() const			// return size of fm
			{ return arcs.size(); }
	set<state>&	sources(set<state>&) const;	// sinks states of fm
	fm<Label>&	star();				// ``*'' of fm
	set<state>&	starts(set<state>& r) const	// all start states
			{ return r=start_states; }
	void		stats(ostream&) const;
	set<state>&	states(set<state>&) const;	// all states
	fm<Label>&	subset();			// subset construction
 	int		fmtofl(fl<Label>&) const;	// conversion to fl
 	void		fltofm(const fl<Label>&);	// conversion from fl
 	void		flfilter(fl<Label>&) const;	// filter fl
 	int		is_finite() const;		// represents fl ?
};

#define		FM_CLASS_DEFINITION
#endif

