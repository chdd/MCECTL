.de EX		
.if \\n(.$>1 .tm troff: tmac.an: \\*(.F: extra arguments ignored
.sp \\n()Pu
.ne 8v
.ie \\n(.$ .nr EX 0\\$1n
.el .nr EX 0.5i
.in +\\n(EXu
.nf
.CW
..
.de EE		
.if \\n(.$>0 .tm troff: tmac.an: \\*(.F: arguments ignored
.R
.fi
.in -\\n(EXu
.sp \\n()Pu
..
.TH afaunion 1 "Grail"
.SH NAME
afaunion \- compute the union of two alternating finite state machines
.SH SYNOPSIS
.B afaunion afa1 afa2
.sp
.B afaunion afa2 <afa1 
.SH DESCRIPTION
.B
afaunion
computes the union of \fIafa1\fR and \fIafa2\fR.  This is done
by first checking the ordered input symbols of the two \fIafas\fR. 
If the input symbols are the same, then does the union and writes 
the resulting \fIafa\fR on the standard output; otherwise 
writes \fB"the alphabets are not the same"\fR on the standard error.
.LP
\fIafa1\fR and \fIafa2\fR must conform to the Grail bit-wise \fIafa\fR format 
for machines.
.SH EXAMPLES
.EX
% cat bitafa1
symbols: [a,b]
states:  3
finals:  5
head: 7 4
7 5
7 1
0 1
3 1
6 2
7 3

% cat bitafa3
symbols: [a,b]
states:  4
finals:  7
head: 1 1
14 2+15 12
15 6
15 7
14 8+14 6+15 14
15 2+7 1+15 7
15 8+15 4
15 3+15 10
14 8+15 4

%cat bitafa2
symbols: [a,b,c]
states:  3
finals:  2
head: 7 4
6 2+7 1
7 1
0 1
0 1
6 2+7 1
0 1
0 1
0 1
7 3

% afaunion bitafa1 bitafa3
symbols: [a,b]
states:  7
finals:  61
head: 7 4+8 8
7 5
7 1
0 1
3 1
6 2
7 3
112 16+120 96
120 48
120 56
112 64+112 48+120 112
120 16+56 8+120 56
120 64+120 32
120 24+120 80
112 64+120 32

%afaunion bitafa1 < bitafa3
symbols: [a,b]
states:  7
finals:  61
head: 7 4+8 8
7 5
7 1
0 1
3 1
6 2
7 3
112 16+120 96
120 48
120 56
112 64+112 48+120 112
120 16+56 8+120 56
120 64+120 32
120 24+120 80
112 64+120 32

%cat bitafa3 | afaunion bitafa1
symbols: [a,b]
states:  7
finals:  61
head: 7 4+8 8
7 5
7 1
0 1
3 1
6 2
7 3
112 16+120 96
120 48
120 56
112 64+112 48+120 112
120 16+56 8+120 56
120 64+120 32
120 24+120 80
112 64+120 32

%afaunion bitafa1 bitafa2
the alphabets are not the same
.EE
.SH AUTHORS
Xiuming Wu and Sheng Yu, the Grail project
.SH "SEE ALSO"
afa(5)
