.de EX		
.if \\n(.$>1 .tm troff: tmac.an: \\*(.F: extra arguments ignored
.sp \\n()Pu
.ne 8v
.ie \\n(.$ .nr EX 0\\$1n
.el .nr EX 0.5i
.in +\\n(EXu
.nf
.CW
..
.de EE		
.if \\n(.$>0 .tm troff: tmac.an: \\*(.F: arguments ignored
.R
.fi
.in -\\n(EXu
.sp \\n()Pu
..
.TH afaexec 1 "Grail"
.SH NAME
afaexec \- execute a machine on an input string
.SH SYNOPSIS
.B afaexec afa string
.sp
.B afaexec string <afa
.SH DESCRIPTION
.B
afaexec
tests the word \fIstring\fR for membership in the language of the
machine \fIafa\fR.  If \fIstring\fR is accepted,
.B
afaexec 
returns 1 and writes \fB"input was accepted"\fR on its standard error;
If all the symbols of the \fIstring\fR are in the input symbol set and the 
\fIstring\fR is not in the language of the \fIafa\fR, it returns 0 and writes
\fB"input was not accepted"\fR on its standard error; Otherwise it writes
\fB"the input symbol is not legal"\fR on its standard error.
.LP 
\fIafa\fR must conform to the Grail bit-wise format for machines. 
\fIstring\fR should probably be protected from the shell by double 
quotes. 
.SH EXAMPLES
.EX
% cat bitafa2
symbols: [a,b,c]
states:  3
finals:  2
head: 7 4
6 2+7 1
7 1
0 1
0 1
6 2+7 1
0 1
0 1
0 1
7 3

% afaexec bitafa2 "abc"
input was accepted

% afaexec bitafa2 "abbb"
input was not accepted

%afaexec "abc" < bitafa2
input was accepted

% afaexec bitafa2 "x"
the input symbol is not legal 

%cat bitafa2 | afaexec "abc"
input was accepted

%cat bitafa2 | afaexec "abbb"
input was not accepted

%cat bitafa2 | afaexec "x"
the input symbol is not legal
.EE
.SH AUTHORS
Xiuming Wu and Sheng Yu, the Grail project
.SH "SEE ALSO"
afa(5)
