.de EX		
.if \\n(.$>1 .tm troff: tmac.an: \\*(.F: extra arguments ignored
.sp \\n()Pu
.ne 8v
.ie \\n(.$ .nr EX 0\\$1n
.el .nr EX 0.5i
.in +\\n(EXu
.nf
.CW
..
.de EE		
.if \\n(.$>0 .tm troff: tmac.an: \\*(.F: arguments ignored
.R
.fi
.in -\\n(EXu
.sp \\n()Pu
..
.TH fmcat 1 "Grail"
.SH NAME
afacaten \- catenate two machines
.SH SYNOPSIS
.B afacaten bitafa1 bitafa2
.sp
.B afacaten bitafa2 <bitafa1
.SH DESCRIPTION
.B
afacaten 
computes the catenation of \fIbitafa1\fR and \fIbitafa2\fR, writing 
the result on the standard output.  \fIbitafa1\fR and \fIbitafa2\fR need not
be distinct.
.B
afacaten
first check if the resulting machine has more 32 states or not. If it does, 
the filter report to user that \fIthe machines are too big for 
concatenation\fR, otherwise it construct the concatenation machine by 
using the power set construction.
.LP
\fIbitafa1\fR and \fIbitafa2\fR must conform to the Grail format for 
bit-wise afa.
.SH EXAMPLES
.EX
% cat bitafa1
symbols: [a,b]
states:  2
finals:  1
head: 3 2
0 1
0 1
3 1
3 1

% afacaten bitafa1 bitafa1
symbols: [a,b]
states:  6
finals:  1
head: 16 16
0 1
0 1
3 1
3 1
4 4+16 16+32 32
4 4+16 16+32 32
3 1
3 1
8 8
8 8
0 1
0 1


% cat bitafa2
symbols: [c,d]
states:  2
finals:  2
head: 1 1
3 2
3 1
0 1
3 1


% afacaten bitafa2 bitafa1
symbols: [a,b,c,d]
states:  11
finals:  2
head: 32 32
0 1
0 1
3 2
3 1
0 1
0 1
0 1
3 1
0 0
0 0
4 4
4 4
8 8+32 32+64 64
8 8+32 32+64 64
0 1
0 1
0 1
0 1
7 2
7 1
16 16
16 16
0 1
0 1
0 1
0 1
0 1
0 1
128 128+512 512+1024 1024
128 128+512 512+1024 1024
8 8+16 16+32 32+64 64+128 128+256 256+512 512+1024 1024
8 8+16 16+32 32+64 64+128 128+256 256+512 512+1024 1024
0 1
0 1
0 1
0 1
256 256
256 256
0 1
0 1
0 1
0 1
0 1
0 1

.EE
.SH AUTHORS
Darrell Raymond and Derick Wood, the Grail project
.SH "SEE ALSO"
fm(5)
