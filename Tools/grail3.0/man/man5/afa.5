.de EX		
.if \\n(.$>1 .tm troff: tmac.an: \\*(.F: extra arguments ignored
.sp \\n()Pu
.ne 8v
.ie \\n(.$ .nr EX 0\\$1n
.el .nr EX 0.5i
.in +\\n(EXu
.nf
.CW
..
.de EE		
.if \\n(.$>0 .tm troff: tmac.an: \\*(.F: arguments ignored
.R
.fi
.in -\\n(EXu
.sp \\n()Pu
..
.TH AFA 5 "Grail"
.SH NAME
afa \- format for alternating finite-state machines
.SH DESCRIPTION
.LP
The standard description of an alternating  finite-state machine (usually 
called an afa) is as a 5-tuple:
.sp
.ce
\fI<{states}, {labels}, head-function, transition-function, {final-states}>\fR
.LP
In \fIGrail\fR, we have two representations for an afa. The first one is 
called literal representation. In this representation, each Boolean 
function which is in disjunctive normal form is represented as a summation 
of literal Boolean terms. 
For example:
.EX
~q1q2~q3~q4+q1~q2~q3+q1q2q3~q4
.EE
where qi is the ith Boolean variable, ~qi is the negation of the 
ith Boolean variable. 
.LP
Every AFA is represented as:
.EX
symbols: \fIarray of ordered input symbols\fR
states: \fInumber of state of the afa\fR
finals: \fIlist of final states\fR
head: \fIliteral representation of the head-function\fR
\fIList of transition functions\fR (each line is a transition for a state 
at an input symbol)
.EE
.LP
Notice that we always assume that the states of the AFA are numbered from 1 
to some number n, or 0 to indicate no states. Assume that the size of the 
input symbol array is m, and that the (i-1)*m + j line of the transition 
function list is the transition function of the ith state at the jth input 
symbol. 
.LP
Here is an example of a literal afa:
.EX
symbols: [a,b]
states: 7
finals: q1 q2 q3 q5 q7 
head: q1~q5~q6q7
q2~q3~q4+~q1~q2q3q4
~q1q2q3~q4
q1q2q3~q4
~q2~q3q4+q2q3~q4+~q1q2q3q4
~q1q2~q3~q4+q1~q2~q3+q1q2q3~q4
~q1~q2~q3q4+~q1~q2q3~q4
q1q2~q3~q4+~q1q2~q3q4
~q2~q3q4+~q1~q2q3~q4
q5~q6q7
q5~q6~q7
0
q5~q6
q6~q7
q5q6~q7
.EE 
.LP
The above literal representation of AFA is only for the purpose of getting 
a readable AFA for the user. For the actual operations, we use the bit-wise 
representation for AFA. In the bit-wise representation, we use a pair of 
integers to represent a term, and use a summation of pairs of integers to 
represent a Boolean expression which is in disjunctive normal form. For 
example, by using  bit-wise representation, the above literal AFA is 
represented as follows: 
.EX
symbols: [a,b]
states:  7
finals:  87
head: 113 65
14 2+15 12
15 6
15 7
14 8+14 6+15 14
15 2+7 1+15 7
15 8+15 4
15 3+15 10
14 8+15 4
112 80
112 16
0 16
48 16
96 32
112 48
.EE
.LP
Here we use the same assumptiosn as discussed for the literal 
representation of AFA.
.LP
In \fIGrail\fR, there is no start state and multiple final states 
are permitted for an AFA. The transition functions are ordered.
.LP
\fIGrail\fR supports parameterizable machines.  If the alphabet
of your machine is not the ASCII characters, then the instruction
labels will be a textual represenatation of the objects that
make up the alphabet.
.LP
.SH AUTHORS
Xiuming Wu and Sheng Yu, the Grail project
.SH "SEE ALSO"
re(5)
