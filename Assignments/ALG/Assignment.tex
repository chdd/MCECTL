\documentclass[11pt]{article}
\pdfpagewidth 210mm
\pdfpageheight 297mm
\setlength\topmargin{0in}
\setlength\headheight{0in}
\setlength\headsep{0in}
\setlength\textheight{9.0in}
\setlength\textwidth{6.0in}
\setlength\oddsidemargin{0in}
\setlength\evensidemargin{0in}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}

\usepackage[pdftex]{graphicx}
\usepackage{graphviz}
\begin{document}
\title{Automata, Logic and Games Assignment}
\author{Candidate 680817}
\maketitle

\section*{Question 1}
\subsection*{a)}

$L_1$ is recognised by the following B\"uchi automaton, $A_1$:

\digraph[scale=0.9]{Buchi1}{
%   rankdir=LR; 
   margin=0;
	node [shape = doublecircle, width=0.3]; {rank=same;  3; 6};
	node [shape = circle,  width=0.3] 1 2 4 5 7 8 9;
	node [shape = plaintext, label=""]; INIT;
	INIT -> 1 [ label = "" ];
	1 -> 1 [ label = "a, b, c" ];
	1 -> 2 [ label = "a" ];
	2 -> 2 [ label = "a" ];
	2 -> 3 [ label = "b" ];
	7 -> 3 [ label = "b" ];
	3 -> 4 [ label = "b" ];
	4 -> 4 [ label = "b" ];
	5 -> 4 [ label = "b" ];
	3 -> 5 [ label = "a" ];
	4 -> 5 [ label = "a" ];
	5 -> 5 [ label = "a" ];
   2 -> 6 [ label = "c" ];
	5 -> 6 [ label = "c" ];
	6 -> 7 [ label = "a" ];
	7 -> 7 [ label = "a" ];
	8 -> 7 [ label = "a" ];
	9 -> 7 [ label = "a" ];
   {rank=same;8; 9}
	6 -> 8 [ label = "c" ];
	7 -> 8 [ label = "c" ];
	8 -> 8 [ label = "c" ];
	6 -> 9 [ label = "b" ];
	8 -> 9 [ label = "b" ];
	9 -> 9 [ label = "b" ];
}


$L_2$ is recognised by the B\"uchi automaton $A_2$:

\digraph[scale=0.9]{MyGraph}{
   rankdir=LR; 
   margin=0;
	node [shape = doublecircle, width=0.3]; 1 3; 
	node [shape = circle, width=0.3] 2;
	node [shape = plaintext, label=""]; SECRET;
	SECRET -> 1 [ label = "" ];
	1 -> 1 [ label = "b, c" ];
	1 -> 2 [ label = "a" ];
	2 -> 2 [ label = "b, c" ];
	2 -> 3 [ label = "a" ];
	3 -> 2 [ label = "a, b, c" ];
}

\subsection*{b)}

$L_1$ and $L_2$ are both LTL-definable: let $p_1, p_2, p_3$ be the proposition
variables corresponding to occurrences of the letters $a, b, c$ respectively.
Then $L_1$ is defined by the LTL formula 
\begin{displaymath}
\varphi_1 := \textbf{GF}(p_1 \wedge \textbf{X} p_2) \wedge \textbf{GF}(p_1 \wedge \textbf{X} p_3) \wedge \neg \textbf{GF}(p_2 \wedge \textbf{X} p_3)
\end{displaymath}
and $L_2$ is defined by the LTL formula 
\begin{displaymath}
\varphi_2 := \textbf{F}p_1 \rightarrow \textbf{GF}p_1
\end{displaymath}

\section*{Question 2}

\subsection*{a)}

Consider the following B\"uchi automaton.

$A$:

\digraph[scale=0.8]{Buchi3}{
   rankdir=LR; 
   margin=0;
	node [shape = doublecircle, width=0.3]; 2 3; 
	node [shape = circle, width=0.3] 1;
	node [shape = plaintext, label=""]; SECRET;
	SECRET -> 1 [ label = "" ];
	1 -> 2 [ label = "a" ];
	1 -> 3 [ label = "b" ];
	2 -> 2 [ label = "a" ];
	3 -> 3 [ label = "b" ];
}

This automaton accepts the language $L = a^\omega \cup b^\omega$, so $L$ is
clearly B\"uchi recognisable. Now suppose for a contradiction that $L$ is
strongly B\"uchi-recognisable. Then there exists a B\"uchi automaton $\mathcal{A} =
(Q, \Sigma, q_0, \Delta, F)$ such that $\alpha \in L $ iff there is a run
$\varphi$ of $\mathcal{A}$ on $\alpha$ such that $\textbf{inf}(\varphi) \cap F
= F$.
We have $a^\omega \in L $ and $b^\omega \in L$, so let $\rho$ and $\sigma$ be
runs of $\mathcal{A}$ on $a^\omega$ and $b^\omega$ respectively, such that
$\textbf{inf}(\rho) \cap F = F = \textbf{inf}(\sigma) \cap F$.

$F \neq \emptyset$, so let $s \in F$. Since $s \in \textbf{inf}(\rho)$,
$\exists n \in \mathbb{N}$ such that $\rho(n) = s$. Similarly, $\exists m \in
\mathbb{N}$ such that $\sigma(m) = s$.

Now let \begin{displaymath}
\tau(k) = \left\{
     \begin{array}{lr}
       \rho(k) &   k \leq n \\
       \sigma(k-n+m) & k > n \\
     \end{array}
   \right.
   \end{displaymath}

But then $\tau$ is a run of $\mathcal{A}$ on $a^n b^\omega \notin L$, which is
a contradiction. So $L$ is not strongly-B\"uchi recognisable.
Therefore B\"uchi recognisability does \emph{not} imply strong B\"uchi recognisability.

\subsection*{b)}

Suppose $L$ is strongly B\"uchi recognisable; then there is a B\"uchi automaton
$\mathcal{A} = (Q, \Sigma, q_0, \Delta, F)$ such that $\alpha \in L $ iff
there is a run $\rho$ of $\mathcal{A}$ on $\alpha$ such that
$\textbf{inf}(\rho) \cap F = F$. But $\mathcal{A}$ also B\"uchi recognises $L$
via $\rho$ since it is sufficient that $\textbf{inf}(\rho) \cap F \neq
\emptyset$, and $F \neq \emptyset \Rightarrow \textbf{inf}(\rho) \cap F \neq
\emptyset$. Hence $L$ is B\"uchi recognisable.

\section*{Question 3}

Let $\varphi$ be a closed autonomous modal mu-calculus formula in positive normal form. Let $s$ be a state of a labelled transition system $T$.

\subsection*{a)}

Let $\rho$ be an infinite play of the parity game $\mathcal{G}^{T}_{\emptyset}(s, \varphi)$.

\subsubsection*{i)}
It is not necessarily true that there is exactly one fixpoint variable that occurs infinitely often in $\rho$. Consider the following example: 
\begin{displaymath}
\varphi = \mu Y . \mu Z . Y
\end{displaymath}

with transition system $T$:

\digraph[scale=0.8]{LTS1}{
   margin=0;
   rankdir=LR; 
	node [shape = circle, width=0.2] s;
   s -> s
}

Then $\mathcal{G}^{T}_{\emptyset}(s, \varphi)$ is as follows:

\digraph[scale=0.8]{Game1}{
   rankdir=LR; 
   margin=0;
	node [shape = none, width=0.2];
   "(s, μ Y. μ Z. Y)" -> "(s, Y)"
   "(s, Y)" -> "(s, μ Z. Y)"
   "(s, μ Z. Y)" -> "(s, Z)"
   "(s, Z)" -> "(s, Y)"
}

and there is only one possible infinite play, and $Y$ and $Z$ both occur
infinitely often in it.

\subsubsection*{ii)}

Suppose (for a contradiction) that it is not true that the fixpoint variables
that occur infinitely often in $\rho$ are either all greatest fixpoint
variables or all least fixpoint variables.

Then w.l.o.g. let $Z_1$, $Z_2$ be fixpoint variables that occur infinitely
often in $\rho$ and are of different types, say $\mu Z_1 . \psi_1$, $\nu Z_2 .
\psi_2 \in \text{Sub}(\varphi)$.  
By normality $Z_1 \neq Z_2$, and by autonomy $Z_1$ is not free in $\psi_2$ and
$Z_2$ is not free in $\psi_1$.

Let $(t, Z_1)$ be an occurrence of $Z_1$ in $\rho$. $Z_2$ must occur at some
point thereafter, so there must be a path from $(t, Z_1)$ to $(t', Z_2)$ for
some $t' \in T$. Since the only outgoing edge from $(t, Z_1)$ is to $(t,
\psi_1)$, there must in fact be a path from $(t, \psi_1)$ to $(t', Z_2)$.
   
This is only possible if $Z_2$ occurs in $\psi_1$, but since $Z_2$ is not free
in $\psi_1$, we have that $\nu Z_2 . \psi_2 \in \text{Sub}(\psi_1)$. Hence
$Z_1$ subsumes $Z_2$.

However, $Z_1$ must be visited subsequently: say there is a path from
$(t',Z_2)$ to $(t'',Z_1)$ again. Now by a similar argument we obtain that $Z_2$
subsumes $Z_1$. But since $Z_1 \neq Z_2$, this is a contradiction.

\subsection*{b)}

First let us list the fixpoint subformulas of $\varphi$ in decreasing order of size:
\begin{displaymath}
\sigma_1 Z_1. \psi_1,
\sigma_2 Z_2. \psi_2,
\dots,
\sigma_m Z_m. \psi_m
\end{displaymath}

For $0 < i \leq m$, call a vertex $(t, \chi)$ `\textbf{governed by}' fixpoint
variable $Z_i$ iff there exists a path $(t_0, \chi_0) \rightarrow (t_1, \chi_1)
\rightarrow \dots \rightarrow (t_k, \chi_k)$ in the game graph such that:

\begin{enumerate}
   \item{$\chi_0 = \sigma_i Z_i. \psi_i$}
   \item{$t_k = t $}
   \item{$\chi_k = \chi$}
   \item{$\forall j \leq k, \quad (\chi_j = \sigma_r Z_r. \psi_r \Rightarrow  \sigma_r = \sigma_i) $}
\end{enumerate}

i.e. the vertex $(t, \chi)$ is reachable from the fixpoint subformula for $Z_i$
without passing through a vertex for a fixpoint subformula of the opposite
type.

For each vertex $v$ in $V$, the vertex set of $\mathcal{G}^T_{\emptyset}(s,\varphi)$, define:
\begin{displaymath}
   \Phi(v) := \{ Z_i : v \text{ is governed by } Z_i \}
\end{displaymath}
and 
\begin{displaymath}
   f(v) := \left\{
     \begin{array}{lr}
        i \text{ such that max}_{\preceq}(\Phi(v)) = Z_i & : \Phi(v) \neq \emptyset  \\
        m+1 & : \Phi(v) = \emptyset  \\
     \end{array}
   \right.
\end{displaymath} 
where $\preceq$ is the subsumption ordering on the fixpoint variables.

Finally define $V_i = \{ v \in V : f(v) = i \}$.

By this construction, at most $n = m+1$ sets are needed, since $0 < f(v) \leq m+1$.

\subsubsection*{(1)}

By construction; observe that the $V_i$ are the equivalence classes of the relation 
\begin{displaymath}
v \thicksim w \iff f(v) = f(w)
\end{displaymath}
so it follows immediately that they are a partition.

\subsubsection*{(2)}

Suppose that play can return from $v \in V_i$ to $w \in V_j$ where $i < j$. Then there must be a path $v \rightarrow ... \rightarrow  w$.
Note $f(v) = i$ and $f(w) = j$ from the definition of $V_i, V_j$. 

Since $v$ is governed by $Z_i$, there is a path $\sigma_i Z_i . \psi_i
\rightarrow ... \rightarrow v \rightarrow ...  \rightarrow w$.

$i < j$ implies $Z_i$ does not subsume $Z_j$, so $w$ is not governed by $Z_i$
(as $f(w) \neq i$). Hence (via clause 4 of the `governed by' definition) there
exists $r$ such that $\sigma_r Z_r. \psi_r$ is on our path from $v$ to $w$ and
$\sigma_r \neq \sigma_i$. By autonomy then, $Z_r$ is not free in $\psi_i$ and
$Z_i$ is not free in $\psi_r$.

But then $Z_r$ subsumes $Z_j$ yet $r < j$, which is a contradiction.

\subsubsection*{(3)}

By construction we have that all fixed point variables in a given $V_i$ are of
the same type. Hence all infinite plays which remain in $V_i$ are won by the
same player.

\subsection*{c)}

Suppose $T$ is a finite transition system. Whenever play is at a vertex in
region $V_i$, the player corresponding to the fixpoint type of the governing
variable for that region (to whom we shall refer as that region's `owner') must
attempt to win by forcing play to remain in $V_i$; the other player's only hope
is to make the play leave $V_i$. Thus we can analyse the regions $V_i$
independently: the overall winner of the game is determined exactly by the
region play ends up in.

The regions form a tree; the solving algorithm is the process of searching this
tree for the shallowest region such that the region's owner is able to dictate
that play does not leave the region.

Provided we are careful not to repeatedly visit the same regions and vertices,
the algorithm is linear. The following psuedo-code is an outline of the process
-- note that for brevity, some edge cases are ignored. The code for storing the
history-free winning strategy is not explict, but it should be clear how the
strategy could be computed during the traversal process.

\begin{verbatim}
SOLVE(T, s, phi) {
   (regions, fixpoint_type) := PARTITION(T, s, phi)
   intial_region = find_region((s, phi))
   fringe = { initial_region }
   while ( fringe != { } ):
      current_region = fringe.pop()
      result = SOLVE_REGION(regions[current_region], fixpoint_type[current_region])

      if ( ! result ):
         # A `true' result indicates that the player's owner can ensure play
         # remains in the region, and thus win - so we have found the winner
         # return fixpoint_type[current_region]
      else
         # The play can be made to leave the region, so we must examine the
         # child regions instead
         for r in child_regions(current_region):
            fringe.append(r)
         
   assert(false)
}

# For each vertex in V_i, determine whether the non-region player can force a
# play beginning from that vertex to leave the region
SOLVE_REGION(region, fixpoint_type) {
   initial = get_root_vertex(region)
   seen := { }
   fringe := { }
   force := { }
   for v in region:
      if any v.successors() not in region:
         fringe.append(v)

   while ( fringe != { } ):
      v = fringe.pop()
      seen.append(v)
      if owner(v) != fixpoint_type:
         force.append(v)
         for w in v.predecessors():
            if w not in seen:
               fringe.append(w)

   if initial in force:
      return false
   else
      return true
}

# This routine traverses the game graph (using BFS without repeated states) and
# constructs a partition of the vertex set consistent with the properties 
# described above. The set V_i is stored in regions[i], and the fixpoint type of
# the maximally subsuming fixpoint variable in V_i is also stored in 
# fixpoint_type[i]
PARTITION(T, s, phi) {
   fringe  := { ((s,phi), n+1) }
   visited := { }
   fixpoint_type := []
   regions := []
   for k in 1 .. n+1:
      fixpoint_type[k] = none
      regions[k] = { }

   # j keeps track of the latest partition region that has been encountered
   j = m + 1

   while ( fringe != {} ):
      ((t, psi), i) = fringe.pop()
      visited.append( (t, psi) )
      regions[i].append( (t, psi) )

      if (is_fixpoint_subformula(psi'):
         fixpoint_type[i] = get_fixpoint_type(psi)

      for (t', psi') in successors( (t, psi) ):
         if (t', psi') not in visited:

            # A change of fixpoint type means a new region
            # (otherwise same as parent vertex)
            if (is_fixpoint_subformula(psi') and
                  fixpoint_type[i] != get_fixpoint_type(psi')):
               j--; assert(j > 0)

            fringe.append( ((t', psi'), j) )

   return (regions, fixpoint_type)
}

\end{verbatim}

For an example, see the addendum.

\section*{Question 4}
\subsection*{a)}

We define a translation from CTL to the modal mu-calculus by structural
induction, as described by the following table, where the translation of a
subformula $\varphi$ is obtained via the inductive hypothesis, and is written
$\bar{\varphi}$:

\begin{displaymath}
\begin{array}{c | c}
\text{CTL} & \text{Modal mu-calculus} \\
\hline
p                   & p \\
\neg \varphi        & \neg \bar{\varphi} \\
\varphi \wedge \psi & \bar{\varphi} \wedge \bar{\psi} \\
\quad [K]\varphi    & [K] \bar{\varphi} \\
\textbf{A}(\varphi \textbf{U} \psi) & \mu Z . \bar{\psi} \vee ( \bar{\varphi} \wedge [-] Z ) \\
\textbf{E}(\varphi \textbf{U} \psi) & \mu Z . \bar{\psi} \vee ( \bar{\varphi} \wedge \langle - \rangle Z ) \\

\end{array}
\end{displaymath}

Note that (of course) a fresh fixpoint variable must be used for each separate
Until clause.

For the embedding to be correct we require that for a state $s$ of an arbitrary
transition system $T$, $s \models^{T} \varphi$ iff $s \models^{T}_{\emptyset}
\bar{\varphi}$, where $\varphi$ is a CTL formula and $\bar{\varphi}$ is its
mu-calculus translation.

This holds true by induction: a state satisfies the $j$'th approximant of the translation of
a $\textbf{E}(\varphi\textbf{U}\psi)$ clause iff there is a path $\pi$ of length $j$ in the transition system such
that $\pi(1) = s$, $\pi(i) \models \psi$ for $i < j$ and $\pi(j) \models \varphi$.
A similar result is valid for $\textbf{A}(\varphi\textbf{U}\psi)$.

\subsection*{b)}

Since the translation from CTL only uses greatest fixed points, the resulting
formula will be autonomous. This suggests an efficient approach to deciding the
CTL model-checking problem via the modal mu-calculus embedding described above.
It is sufficient to convert the CTL formula to a modal mu-calculus one, then
construct and solve the corresponding parity game using the algorithm of
question 3. If player V wins the game then the state satisfies the formula; if
R wins then it does not.

The translation can increase the size of the formula somewhat, but within a
constant factor. The number of states in the model-checking game is bounded by
the product of the number of states in the transition system and the size of
the modal mu-calculus formula. Solving the game is linear in the number of
states. Hence the overall time complexity of this approach is
$\mathcal{O}(|\varphi||S|)$ where $\varphi$ is the CTL formula and $S$ is the state
set of the transition system.

\subsubsection*{Example}

Transition system $T$:

\digraph[scale=1.0]{LTS2}{
   margin=0;
   rankdir=LR; 
   node [shape = circle, width=0.3, label = "s : {p}"] s;
   node [shape = circle, width=0.3, label = "t : {q}"] t;
   s -> s [label = "a"];
   s -> t [label = "a"];
}

CTL formula $\varphi = \textbf{X}q \wedge \textbf{A}(p\textbf{U}q)$

First we translate to the modal mu-calculus:
$\bar{\varphi} = \langle - \rangle q \wedge \mu Z . q \vee (p \wedge [-]Z)$

Now construct the game graph:
Then $\mathcal{G}^{T}_{\emptyset}(s, \varphi)$ is as follows:

\digraph[scale=0.8]{Game2}{
   margin=0;
	node [shape = none, width=0.2];
   node [label="R: (s, <a>q ^ μ Z . q v (p ^ [a] Z)"] 2;
   node [label="V: (s, <a>q)"] 3;
   node [label="(s, μ Z . q v (p ^ [a]Z)"] 4;
   node [label="(s, q)"] 5;
   node [label="(t, q)"] 6;
   node [label="(s, Z)"] 7;
   node [label="V: (s, q v (p ^ [a]Z))"] 8;
   node [label="R: (s, p ^ [a]Z)"] 9;
   node [label="(s, p)"] 10;
   node [label="R: (s, [a]Z)"] 11;
   node [label="(t, Z)"] 12;
   2 -> 3;
   2 -> 4;
   3 -> 5;
   3 -> 6;
   4 -> 7;
   7 -> 8;
   8 -> 5;
   8 -> 9;
   9 -> 10;
   9 -> 11;
   11 -> 7;
   11 -> 12;
}

The partition algorithm creates two regions: $V_2 = \{ (s, \langle - \rangle q \wedge \mu Z . q \vee (p \wedge [-]Z)), (s,  \langle - \rangle q ), (t, q) \}$, and $V_1$ contains all other vertices.
Solving $V_2$ we find that the $R$ player can force play to leave the region,
so we need to solve $V_1$. $V_1$ is a greatest fixpoint region, and play cannot
leave, so $V$ wins. This indicates that $s$ does satisfy the CTL formula, as
expected.

\end{document}

